#+TITLE: Org-ref - The best reference handling for org-mode
#+AUTHOR: John Kitchin
#+DATE: April 29, 2014

* Introduction

This document is an experiment at creating a literate program to provide similar features as reftex for org-mode referencing. These features include:

1. using completion to create links
2. storing links to places, 
3. Clickable links that do useful things
4. Exportable links to LaTeX
5. Utility functions for dealing with bibtex files and org-files


** Header
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
;;; org-ref.el --- setup bibliography, cite, ref and label org-mode links.

;; Copyright(C) 2014 John Kitchin

;; Author: John Kitchin <jkitchin@andrew.cmu.edu>
;; This file is not currently part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or (at
;; your option) any later version.

;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program ; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary:
;;
;; Lisp code to setup bibliography cite, ref and label org-mode links.
;; also sets up reftex for org-mode. The links are clickable and do
;; things that are useful. You should really read org-ref.org for details.
#+END_SRC

** requires
The only external require is reftex-cite

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(require 'reftex-cite)
#+END_SRC

** Custom variables
There are some variables needed later to tell this library where you store your pdf files, where your notes file is, and your default bibliography. This variable is similar to the reftex-default-bibliography. I do not remember why I made it separate.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defgroup org-ref nil
  "customization group for org-ref")

(defcustom org-ref-bibliography-notes
  nil
  "filename to where you will put all your notes about an entry in
  the default bibliography."
  :type 'file
  :group 'org-ref)

(defcustom org-ref-default-bibliography
  nil
  "list of bibtex files to search for. You should use full-paths for each file."
  :type '(repeat :tag "List of bibtex files" file)
  :group 'org-ref)

(defcustom org-ref-pdf-directory
  nil
  "directory where pdfs are stored by key. put a trailing / in"
  :type 'directory
  :group 'org-ref)
#+END_SRC

** org-mode / reftex setup

We setup reftex here. We use a custom insert cite link function defined here: [[*org-ref-insert-cite-link][org-ref-insert-cite-link]]. We setup reftex to use our org citation format.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-mode-reftex-setup ()
    (load-library "reftex")
    (and (buffer-file-name)
         (file-exists-p (buffer-file-name))
	 (global-auto-revert-mode t)
         (reftex-parse-all))
    (make-local-variable 'reftex-cite-format)
    (setq reftex-cite-format 'org)
    (define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-cite-link))

(add-hook 'org-mode-hook 'org-mode-reftex-setup)


;; We make two formats. The default inserts a cite link. the "a"
;; format is for (a)ppending citations on an existing citation
(eval-after-load 'reftex-vars
  '(progn
      (add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l")
			  (?a . ",%l"))))))
#+END_SRC

* Links
Most of this library is the creation of functional links to help with references and citations.
** General utilities
We need several general utilities for this module. They are organized here. We frequently need to remove white space from the front and back of a string. Here we do that for a string.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-strip-string (string)
  "strip leading and trailing whitespace from the string"
  (interactive)
  (replace-regexp-in-string
   (concat search-whitespace-regexp "$" ) ""
   (replace-regexp-in-string
    (concat "^" search-whitespace-regexp ) "" string)))
#+END_SRC

It is helpful to make the previous function operate on a list of strings here.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-split-and-strip-string (string)
  "split key-string and strip keys. Assumes the key-string is comma delimited"
  (mapcar 'org-ref-strip-string (split-string string ",")))
#+END_SRC

** bibliography and bibliographystyle

We use a link for the bibliography so that we can click on it to open the bibliography file. The link may have more than one bibliography file in it, separated by commas. Clicking opens the file under the cursor. The bibliographies should be full filenames with the bib extension. Clicking on this link makes reftex-default-bibliography local and sets it to the list of files in the link. We need this to use reftex's searching capability.

*************** TODO biblatex support
3. I sometimes use biblatex instead of bibtex.  As a result, I do not
     use \bibliography and use \addbibresource instead.  I have
     defined my bibliography files in org-ref-default-bibliography but
     this is only picked up on initialisation.  It is difficult to
     update this for a document in progress (I had to locally set
     reftex-default-bibliography manually).
*************** END


#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(org-add-link-type "bibliography"
		   ;; this code is run on clicking. The bibliography
		   ;; may contain multiple files. this code finds the
		   ;; one you clicked on and opens it.
		   (lambda (link-string)	
		       ;; get link-string boundaries
		       ;; we have to go to the beginning of the line, and then search forward
		       
		     (let* ((bibfile)
			    ;; object is the link you clicked on
			    (object (org-element-context))
 
			    (link-string-beginning) 
			    (link-string-end))

		     (save-excursion
		       (goto-char (org-element-property :begin object))
		       (search-forward link-string nil nil 1)
		       (setq link-string-beginning (match-beginning 0))
		       (setq link-string-end (match-end 0)))

		       ;; We set the reftex-default-bibliography
		       ;; here. it should be a local variable only in
		       ;; the current buffer. We need this for using
		       ;; reftex to do citations.
		       (set (make-local-variable 'reftex-default-bibliography) 
			    (split-string (org-element-property :path object) ","))

		       ;; now if we have comma separated bibliographies
		       ;; we find the one clicked on. we want to
		       ;; search forward to next comma from point
		       (save-excursion
			 (if (search-forward "," link-string-end 1 1)
			     (setq key-end (- (match-end 0) 1)) ; we found a match
			   (setq key-end (point)))) ; no comma found so take the point
		       ;; and backward to previous comma from point
		       (save-excursion
			 (if (search-backward "," link-string-beginning 1 1)
			     (setq key-beginning (+ (match-beginning 0) 1)) ; we found a match
			   (setq key-beginning (point)))) ; no match found
		       ;; save the key we clicked on.
		       (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end)))
		       (message "found %s for bibliography" bibfile)
		       (find-file bibfile))) ; open file on click

		     ;; formatting code
		   (lambda (keyword desc format)
		     (cond
		      ((eq format 'html) (format "")); no output for html
		      ((eq format 'latex)
			 ;; write out the latex bibliography command
		       (format "\\bibliography{%s}" (replace-regexp-in-string  "\\.bib" "" keyword))))))
#+END_SRC

We also create a bibliographystyle link. There is nothing to do on clicking here, and we create it for consistency.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(org-add-link-type "bibliographystyle"
		   (lambda (arg) (message "Nothing implemented for clicking here."))
		   (lambda (keyword desc format)
		     (cond
		      ((eq format 'latex)
		       ;; write out the latex bibliography command
		       (format "\\bibliographystyle{%s}" keyword)))))
#+END_SRC

** List of Figures

In long documents, a list of figures is not uncommon. Here we create a clickable link that generates a temporary buffer containing a list of figures in the document, and their captions. We make a function that can be called interactively, and define a link type that is rendered in LaTeX to create the list of figures.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-list-of-figures (&optional arg)
  "Generate buffer with list of figures in them"
  (interactive)
  (let* ((c-b (buffer-name))
	 (counter 0)
	 (list-of-figures 
	  (org-element-map (org-element-parse-buffer) 'link
	    (lambda (link) 
	      "create a link for to the figure"
	      (when 
		  (and (string= (org-element-property :type link) "file")
		       (string-match-p  
			"[^.]*\\.\\(png\\|jpg\\|eps\\|pdf\\)$"
			(org-element-property :path link)))                   
		(incf counter)
		
		(let* ((start (org-element-property :begin link))
		       (parent (car (cdr (org-element-property :parent link))))
		       (caption (caaar (plist-get parent :caption)))
		       (name (plist-get parent :name)))
		  (if caption 
		      (format 
		       "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]] %s\n" 
		       c-b start counter (or name "") caption)
		    (format 
		     "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]]\n" 
		     c-b start counter (or name "")))))))))
    (switch-to-buffer "*List of Figures*")
    (org-mode)
    (erase-buffer)
    (insert (mapconcat 'identity list-of-figures ""))
    (setq buffer-read-only t)
    (use-local-map (copy-keymap org-mode-map))
    (local-set-key "q" #'(lambda () (interactive) (kill-buffer)))))

(org-add-link-type 
 "list-of-figures"
 'org-ref-list-of-figures ; on click
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\listoffigures")))))
#+END_SRC

** List of Tables

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-list-of-tables (&optional arg)
  "Generate a buffer with a list of tables"
  (interactive)
  (let* ((c-b (buffer-name))
	 (counter 0)
	 (list-of-tables 
	  (org-element-map (org-element-parse-buffer 'element) 'table
	    (lambda (table) 
	      "create a link for to the table"
	      (incf counter)
	      (let ((start (org-element-property :begin table))
		    (name  (org-element-property :name table))
		    (caption (caaar (org-element-property :caption table))))
		(if caption 
		    (format 
		     "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]] %s\n" 
		     c-b start counter (or name "") caption)
		  (format 
		   "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]]\n" 
		   c-b start counter (or name ""))))))))
    (switch-to-buffer "*List of Tables*")
    (org-mode)
    (erase-buffer)
    (insert (mapconcat 'identity list-of-tables ""))
    (setq buffer-read-only t)
    (use-local-map (copy-keymap org-mode-map))
    (local-set-key "q" #'(lambda () (interactive) (kill-buffer)))))

(org-add-link-type 
 "list-of-tables"
 'org-ref-list-of-tables
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\listoftables")))))
#+END_SRC
** label

The label link provides a way to create labels in org-mode. We make it clickable because we want to make sure labels are unique. This code will tell you how many instances of a label are found.  We search for label links, LaTeX labels, and the org-mode format for labels. We probably should search for tblnames too.
*************** TODO search tblnames, custom_ids and check for case sensitivity
*************** END

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(org-add-link-type
 "label"
 (lambda (label)
   "on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels!"
   (message (format "%s occurences"
		    (+ (count-matches (format "label:%s\\b" label) (point-min) (point-max) t)
		       (count-matches (format "\\label{%s}\\b" label) (point-min) (point-max) t)
                       ;; this is the org-format #+label:
		       (count-matches (format "#\\+label:%s\\b" label) (point-min) (point-max) t)))))
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<label>%s</label>)" path))
    ((eq format 'latex)
     (format "\\label{%s}" keyword)))))
#+END_SRC

We want to store links on labels, so you can put the cursor on the label, press C-c l, and later use C-c C-l to insert a link to the label. We also want to store links to tables with a table name, and for sections with CUSTOM_ID.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-label-store-link ()
  "store a link to a label. The output will be a ref to that label"
  ;; First we have to make sure we are on a label link. 
  (let* ((object (org-element-context)))
    (when (and (equal (org-element-type object) 'link) 
               (equal (org-element-property :type object) "label"))
      (org-store-link-props
       :type "ref"
       :link (concat "ref:" (org-element-property :path object))))

    ;; Store link on table
    (when (equal (org-element-type object) 'table)
      (org-store-link-props
       :type "ref"
       :link (concat "ref:" (org-element-property :name object))))

;; it turns out this does not work. you can already store a link to a heading with a CUSTOM_ID
    ;; store link on heading with custom_id
;    (when (and (equal (org-element-type object) 'headline)
;	       (org-entry-get (point) "CUSTOM_ID"))
;      (org-store-link-props
;       :type "ref"
;       :link (concat "ref:" (org-entry-get (point) "CUSTOM_ID"))))

    ;; and to #+label: lines
    (when (and (equal (org-element-type object) 'paragraph)
	       (org-element-property :name object))
      (org-store-link-props
       :type "ref"
       :link (concat "ref:" (org-element-property :name object))))
))

(add-hook 'org-store-link-functions 'org-label-store-link)
#+END_SRC
** ref

The ref link allows you make links to labels. Clicking on the link takes you to the label, and provides a mark to go back to. 

At the moment, ref links are not usable for section links. You need [[#CUSTOM_ID]] type links.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(org-add-link-type
 "ref"
 (lambda (label)
   "on clicking goto the label. Navigate back with C-c &"
   (org-mark-ring-push)
   ;; next search from beginning of the buffer

   (unless
       (or
	;; our label links
	(progn 
	  (goto-char (point-min))
	  (re-search-forward (format "label:%s" label) nil t))

	;; a latex label
	(progn
	  (goto-char (point-min))
	  (re-search-forward (format "\\label{%s}" label) nil t))

	;; #+label: name  org-definition
	(progn
	  (goto-char (point-min))
	  (re-search-forward (format "^#\\+label:\\s-*\\(%s\\)\\b" label) nil t))
	
	;; org tblname
	(progn
	  (goto-char (point-min))
	  (re-search-forward (format "^#\\+tblname:\\s-*\\(%s\\)\\b" label) nil t))

;; Commented out because these ref links do not actually translate correctly in LaTeX.
;; you need [[#label]] links.
	;; CUSTOM_ID
;	(progn
;	  (goto-char (point-min))
;	  (re-search-forward (format ":CUSTOM_ID:\s-*\\(%s\\)" label) nil t))
	)
     ;; we did not find anything, so go back to where we came
     (org-mark-ring-goto)
     (error "%s not found" label))
   (message "go back with (org-mark-ring-goto) `C-c &`"))
 ;formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<ref>%s</ref>)" path))
    ((eq format 'latex)
     (format "\\ref{%s}" keyword)))))
#+END_SRC

It would be nice to use completion to enter a ref link, where a list of labels is provided. The following code searches the buffer for labels, custom_ids, and table names as potential items to make a ref link to.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-get-custom-ids ()
 "return a list of custom_id properties in the buffer"
 (interactive)
 (let ((results '()) custom_id)
   (org-map-entries 
    (lambda () 
      (let ((custom_id (org-entry-get (point) "CUSTOM_ID")))
	(when (not (null custom_id))
	  (setq results (append results (list custom_id)))))))
results))
#+END_SRC

Here we get a list of the labels defined as raw latex labels, e.g. \label{eqtre}.
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-get-latex-labels ()
(interactive) 
(save-excursion
    (goto-char (point-min))
    (let ((matches '()))
      (while (re-search-forward "\\\\label{\\([a-zA-z0-9:-]*\\)}" (point-max) t)
	(add-to-list 'matches (match-string-no-properties 1) t))
matches)))
#+END_SRC

Finally, we get the table names.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-get-tblnames ()
  (interactive)
  (org-element-map (org-element-parse-buffer 'element) 'table
    (lambda (table) 
      (org-element-property :name table))))
#+END_SRC

Now, we can put all the labels together which will give us a list of candidates.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-get-labels ()
  "returns a list of labels in the buffer that you can make a ref link to. this is used to auto-complete ref links."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((matches '()))
      (while (re-search-forward "label:\\([a-zA-z0-9:-]*\\)" (point-max) t)
	(add-to-list 'matches (match-string-no-properties 1) t))
      (append matches (org-ref-get-latex-labels) (org-ref-get-tblnames) (org-ref-get-custom-ids)))))
#+END_SRC

Now we create the completion function. This works from the org-machinery, e.g. if you type C-c C-l to insert a link, and use completion by pressing tab.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-complete-link (&optional arg)
  "Completion function for ref links"
  (let ((label))
    (setq label (completing-read "label: " (org-ref-get-labels)))
    (format "ref:%s" label)))
#+END_SRC

Alternatively, you may want to just call a function that inserts a link with completion:

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-insert-ref-link ()
 (interactive)
 (insert (org-ref-complete-link)))
#+END_SRC

** eqref
This is just the LaTeX ref for equations. On export, the reference is enclosed in parentheses.
 
#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(org-add-link-type
 "eqref"
 (lambda (label)
   "on clicking goto the label. Navigate back with C-c &"
   (org-mark-ring-push)
   ;; next search from beginning of the buffer
   (goto-char (point-min))
   (unless
       (or
	;; search forward for the first match
	;; our label links
	(re-search-forward (format "label:%s" label) nil t)
	;; a latex label
	(re-search-forward (format "\\label{%s}" label) nil t)
	;; #+label: name  org-definition
	(re-search-forward (format "^#\\+label:\\s-*\\(%s\\)\\b" label) nil t))
     (org-mark-ring-goto)
     (error "%s not found" label))
   (message "go back with (org-mark-ring-goto) `C-c &`"))
 ;formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<eqref>%s</eqref>)" path))
    ((eq format 'latex)
     (format "\\eqref{%s}" keyword)))))
#+END_SRC

** cite
This is the main reason this library exists. We want the following behavior. A cite link should be able to contain multiple bibtex keys. You should be able to click on the link, and get a brief citation of the entry for that key, and a menu of options to open the bibtex file, open a pdf if you have it, open your notes on the entry, or open a url if it exists. You should be able to insert new references onto an existing cite link, or create new ones easily. The following code implements these features.

*** Implementing the click actions of cite
The first thing we need is to get the bibtex key we clicked on.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-get-bibtex-key-under-cursor ()
  "returns key under the bibtex cursor. We search forward from
point to get a comma, or the end of the link, and then backwards
to get a comma, or the beginning of the link. that delimits the
keyword we clicked on. We also strip the text properties."
  (interactive)
  (let* ((object (org-element-context))	 
	 (link-string (org-element-property :path object)))    
    (when (and (equal (org-element-type object) 'link) 
               (equal (org-element-property :type object) "cite"))
      ;; we need the link path start and end
      (save-excursion
	(goto-char (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning (match-beginning 0))
	(setq link-string-end (match-end 0)))

      ;; The key is the text between commas, or the link boundaries
      (save-excursion
	(if (search-forward "," link-string-end t 1)
	    (setq key-end (- (match-end 0) 1)) ; we found a match
	  (setq key-end link-string-end))) ; no comma found so take the end
      ;; and backward to previous comma from point which defines the start character
      (save-excursion
	(if (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning (+ (match-beginning 0) 1)) ; we found a match
	  (setq key-beginning link-string-beginning))) ; no match found
      ;; save the key we clicked on.
      (setq bibtex-key (org-ref-strip-string (buffer-substring key-beginning key-end)))
      (set-text-properties 0 (length bibtex-key) nil bibtex-key)
      (message "you selected %s" bibtex-key)
      bibtex-key
      )))
#+END_SRC

We also need to find which bibliography file that key is in. For that, we need to know which bibliography files are referred to in the file. If none are specified with a bibliography link, we use the default bibliography. This function searches for a bibliography link, and then the LaTeX bibliography link.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-find-bibliography ()
  "find the bibliography in the buffer.
This function sets and returns cite-bibliography-files, which is a list of files
either from bibliography:f1.bib,f2.bib
\bibliography{f1,f2}
internal bibliographies

falling back to what the user has set in org-ref-default-bibliography
"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    ;;  look for a bibliography link
    (re-search-forward "bibliography:\\([^\]\|\n]+\\)" nil t)
    (if (match-string 1) ; we found a link
	(progn
	  (setq org-ref-bibliography-files
		(mapcar 'org-ref-strip-string (split-string (match-string 1) ",")))
	  (message "org-ref-bibliography-files = %s from %s" org-ref-bibliography-files (match-string 1)))
      (progn ;we did not find a bibliography link. now look for \bibliography
	(message "no bibliography link found")
	(goto-char (point-min))
	(re-search-forward "\\\\bibliography{\\([^}]+\\)}" nil t)
	(if (match-string 1) ; we found a link
	    ;; split, and add .bib to each file
	    (setq org-ref-bibliography-files
		  (mapcar (lambda (x) (concat x ".bib"))
			  (mapcar 'org-ref-strip-string 
				  (split-string (match-string 1) ","))))
	 ; we did not find a raw latex bibliography. use defaults
	  (setq org-ref-bibliography-files org-ref-default-bibliography)
	  (message "org-ref-bibliography-files = %s" org-ref-bibliography-files)))))
  (message "org-ref-bibliography-files = %s" org-ref-bibliography-files)
  ;; set reftex-default-bibliography so we can search
  (set (make-local-variable 'reftex-default-bibliography) org-ref-bibliography-files)
  org-ref-bibliography-files)
#+END_SRC

Now, we can see if an entry is in a file. 

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-key-in-file-p (key filename)
  "determine if the key is in the file"
  (with-temp-buffer
    (insert-file-contents filename)
    (bibtex-search-entry key)))
#+END_SRC

Finally, we want to know which file the key is in.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-get-bibtex-key-and-file ()
  "returns the bibtex key and file that it is in under point"
 (interactive)

 (let ((org-ref-bibliography-files (org-ref-find-bibliography))
       key file)
   (setq key (org-ref-get-bibtex-key-under-cursor))
   (setq file     (loop for file in org-ref-bibliography-files do
			    (if (org-ref-key-in-file-p key file) 
				(return file))))
   (message  "you found %s in %s" key file)
   (cons key file)))
#+END_SRC

When we click on a cite link, we want to get a menu in the minibuffer. We need to create a string for this. We want a citation, and some options that depend on the key. We want to know if the key is found, if there is a pdf, if etc... Here we create that string.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-get-menu-options ()
  "returns a dynamically determined string of options for the citation under point.

we check to see if there is pdf, and if the key actually exists in the bibliography"
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat org-ref-pdf-directory "%s.pdf") key))
         (bibfile (cdr results))
	 m1 m2 m3 m4 m5 menu-string)
    (setq m1 (if bibfile		 
		 "(o)pen"
	       "(No key found)"))

    (setq m3 (if (file-exists-p pdf-file)
		 "(p)df"
		     "(No pdf found)"))

    (setq m4 "(u)rl")
    (setq m5 "(n)otes")
    (setq m2 (if bibfile
		 (progn
		   (let ((cb (current-buffer)) citation)
		     (setq citation (progn
				      (set-buffer (find-file-noselect bibfile))
				      (bibtex-search-entry key)  
				      (org-ref-bib-citation)))
		     (set-buffer cb)
		     citation))
	       "no key found"))

    (setq menu-string (mapconcat 'identity (list m2 "\n" m1 m3 m4 m5 "(q)uit") "  "))
    (message "%s" menu-string)
    menu-string))
#+END_SRC

We need some convenience functions to open act on the citation at point. These will get the pdf, open the url, or open the notes.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-open-pdf-at-point ()
  "open the pdf for bibtex key under point if it exists"
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
         (pdf-file (format (concat org-ref-pdf-directory "%s.pdf") key)))
    (if (file-exists-p pdf-file)
	(org-open-file pdf-file)
(message "no pdf found for %s" key))))


(defun org-ref-open-url-at-point ()
  "open the url for bibtex key under point."
  (interactive)
  (let* ((cb (current-buffer))
	 (results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
	 (bibfile (cdr results)))
    (save-excursion
      (set-buffer (find-file-noselect bibfile))
      (bibtex-search-entry key)
      ;; I like this better than bibtex-url which does not always find
      ;; the urls
      (catch 'done
	(let ((url (bibtex-autokey-get-field "url")))
	  (when  url
	    (browse-url url)
	    (throw 'done nil)))

	(let ((doi (bibtex-autokey-get-field "doi")))
	  (when doi
	    (if (string-match "^http" doi)
		(browse-url doi)
	      (browse-url (format "http://dx.doi.org/%s" doi)))
	    (throw 'done nil)))))
    (set-buffer cb)))


(defun org-ref-open-notes-at-point ()
  "open the notes for bibtex key under point."
  (interactive)
  (let* ((cb (current-buffer))
	 (results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
	 (bibfile (cdr results)))
    (save-excursion
	   (find-file bibfile)
	   (bibtex-search-entry key)
	   (org-ref-open-bibtex-notes))))
#+END_SRC
Now, we create the menu.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-cite-onclick-minibuffer-menu (&optional link-string)
  "use a minibuffer to select options for the citation under point.

you select your option with a single key press."
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat org-ref-pdf-directory "%s.pdf") key))
         (bibfile (cdr results))
	 (choice (read-char (org-ref-get-menu-options) )))

    (cond
     ;; open
     ((= choice ?o)
      (find-file bibfile)
       (bibtex-search-entry key))

     ;; cite
     ((= choice ?c)
      (let ((cb (current-buffer)))	
	(message "%s" (progn
			(set-buffer (find-file-noselect bibfile))
			(bibtex-search-entry key)  
			(org-ref-bib-citation)))
	(set-buffer cb)))

     ;; quit
     ((or 
      (= choice ?q) ; q
      (= choice ?\ )) ; space
      ;; this clears the minibuffer
      (message ""))

     ;; pdf
     ((= choice ?p)
      (org-ref-open-pdf-at-point))

     ;; notes
     ((= choice ?n)
      (org-ref-open-notes-at-point))

     ;; url
     ((= choice ?u)
      (org-ref-open-url-at-point))

     ;; anything else we just quit.
     (t (message ""))))
    )
#+END_SRC

Next, we define a formatting function for the cite link. This is done so that the cite link definition is very short, and easy to change. You just need to specify the functions in the definition.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-cite-link-format (keyword desc format)
   (cond
    ((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
     (concat "\\cite{"
	     (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
	     "}"))))
#+END_SRC

Finally, we define the cite link.

*************** TODO format content to get \cite[content]{path}
*************** END

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(org-add-link-type
 "cite"
 'org-ref-cite-onclick-minibuffer-menu
 'org-ref-cite-link-format)
#+END_SRC

*** Miscellaneous cite link variations
I do not use these alot, but they are variations of the regular cite commands in LaTeX. For a good reference on what these do see http://merkel.zoneo.net/Latex/natbib.php. The citet variants are for textual citations, and the citep variants are parenthetical citations. What you actually get seems to depend on the bibliography style you are using.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(org-add-link-type
 "citealp"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<citealp>%s</citealp>)" path))
    ((eq format 'latex)
     (concat "\\citealp{"
	     (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
	     "}")))))

(org-add-link-type
 "citet"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citet{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citet*"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citet*{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

;; TODO these links do not support options [see][]
(org-add-link-type
 "citep"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citep{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citep*"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citep*{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citeauthor"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citeauthor{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citeauthor*"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citeauthor*{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citeyear"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citeyear{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "nocite"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\nocite{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citetext"
 nil ;; clicking does not make sense
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citetext{" path "}")))))
#+END_SRC

*** org-ref-insert-cite-link
We need a convenient method to insert links. In reftex you use the keystroke C-c ], which gives you a minibuffer to search the bibtex files from. This function is bound to that same keystroke here [[*org-mode%20/%20reftex%20setup][org-mode / reftex setup]]. This function will append to a cite link if you call it while on a link.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-insert-cite-link ()
  "Insert a citation link using reftex. If you are on a link, it
appends to the end of the link, otherwise, a new link is
inserted"
  (interactive)
  (let* ((object (org-element-context))
	 (link-string-beginning (org-element-property :begin object))
	 (link-string-end (org-element-property :end object))
	 (path (org-element-property :path object)))    
    
    (cond
     ;; case where we are in a link
     ((and (equal (org-element-type object) 'link) 
	   (equal (org-element-property :type object) "cite"))
      (goto-char link-string-end)
      ;; sometimes there are spaces at the end of the link
      ;; this code moves point pack until no spaces are there
      (while (looking-back " ") (backward-char))  
      (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))

     ;; We are next to a link, and we want to append
     ((save-excursion 
	(backward-char)
	(and (equal (org-element-type (org-element-context)) 'link) 
	     (equal (org-element-property :type (org-element-context)) "cite")))
      (while (looking-back " ") (backward-char))  
      (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))

     ;; insert fresh link
     (t (insert (concat "cite:" (mapconcat 'identity (reftex-citation t) ",")))))))
#+END_SRC

*** Completion in cite links
If you know the specific bibtex key, you may like to use completion directly. You use this with the org-mode machinery and tab completion.
#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-cite-complete-link (&optional arg)
  "Completion function for cite links"
  (format "cite:%s" 
	  (completing-read 
	   "bibtex key: " 
	   (let ((bibtex-files (org-ref-find-bibliography)))
	     (bibtex-global-key-alist)))))
#+END_SRC

Alternatively, you may shortcut the org-machinery with this command.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-insert-cite-with-completion ()
  "Insert a cite link with completion"
  (interactive)
  (insert (org-cite-complete-link)))
#+END_SRC

* Utilities
** create simple text citation from bibtex entry

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-bib-citation ()
  "from a bibtex entry, create and return a simple citation string."
  (interactive)
  (if (eq major-mode 'bibtex-mode)
      (progn
        (bibtex-beginning-of-entry)
        (let* ((cb (current-buffer))
               (bibtex-expand-strings t)
               (entry (bibtex-parse-entry t))
               (title (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "title" entry)))
               (year  (reftex-get-bib-field "year" entry))
               (author (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "author" entry)))
               (key (reftex-get-bib-field "=key=" entry))
               (journal (reftex-get-bib-field "journal" entry))
               (volume (reftex-get-bib-field "volume" entry))
               (pages (reftex-get-bib-field "pages" entry))
               (doi (reftex-get-bib-field "doi" entry))
               (url (reftex-get-bib-field "url" entry))
               )
	  ;;authors, "title", Journal, vol(iss):pages (year).
            (format "%s, \"%s\", %s, %s:%s (%s)"
		    author title journal  volume pages year)))))
#+END_SRC

** open pdf from bibtex
We find this to a key here: [[*key%20bindings%20for%20utilities][key bindings for utilities]].
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-bib-open-bibtex-pdf ()
  "open pdf for a bibtex entry, if it exists. assumes point is in
the entry of interest in the bibfile. but does not check that."
  (interactive)
  (save-excursion
    (bibtex-beginning-of-entry)
    (let* ((bibtex-expand-strings t)
           (entry (bibtex-parse-entry t))
           (key (reftex-get-bib-field "=key=" entry))
           (pdf (format (concat org-ref-pdf-directory "%s.pdf") key)))
      (message "%s" pdf)
      (if (file-exists-p pdf)
          (org-open-link-from-string (format "[[file:%s]]" pdf))
        (ding)))))
#+END_SRC

** open notes from bibtex
We bind this to a key here [[*key%20bindings%20for%20utilities][key bindings for utilities]].

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-open-bibtex-notes ()
  "from a bibtex entry, open the notes if they exist, and create a heading if they do not.

I never did figure out how to use reftex to make this happen
non-interactively. the reftex-format-citation function did not
work perfectly; there were carriage returns in the strings, and
it did not put the key where it needed to be. so, below I replace
the carriage returns and extra spaces with a single space and
construct the heading by hand."
  (interactive)
  (if (eq major-mode 'bibtex-mode)
      (progn
        (bibtex-beginning-of-entry)
        (let* ((cb (current-buffer))
               (bibtex-expand-strings t)
               (entry (bibtex-parse-entry t))
               (title (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "title" entry)))
               (year  (reftex-get-bib-field "year" entry))
               (author (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "author" entry)))
               (key (reftex-get-bib-field "=key=" entry))
               (journal (reftex-get-bib-field "journal" entry))
               (volume (reftex-get-bib-field "volume" entry))
               (pages (reftex-get-bib-field "pages" entry))
               (doi (reftex-get-bib-field "doi" entry))
               (url (reftex-get-bib-field "url" entry))
               )
	  (save-buffer)

	  ;; save key to clipboard to make saving pdf later easier by pasting.
	  (with-temp-buffer
	    (insert key)
	    (kill-ring-save (point-min) (point-max)))

          ;; now look for entry in the notes file
          (if  org-ref-bibliography-notes
	      (find-file org-ref-bibliography-notes)
	    (error "org-ref-bib-bibliography-notes is not set to anything"))

          (goto-char (point-min))
          ;; put new entry in notes if we don't find it.
          (unless (re-search-forward (format ":Custom_ID: %s$" key) nil 'end)
            (insert (format "\n** TODO %s - %s" year title))
            (insert (format"
 :PROPERTIES:
  :Custom_ID: %s
  :AUTHOR: %s
  :JOURNAL: %s
  :YEAR: %s
  :VOLUME: %s
  :PAGES: %s
  :DOI: %s
  :URL: %s
 :END:
[[cite:%s]] [[file:%s/%s.pdf][pdf]]\n\n"
key author journal year volume pages doi url key org-ref-pdf-directory key))
(save-buffer))))))
#+END_SRC

** open url in browser from bibtex

We bind this to a key here [[*key%20bindings%20for%20utilities][key bindings for utilities]].

+ This function may be duplicative of bibtex-url. But I think my function is better unless you do some complicated customization of bibtex-generate-url-list.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-open-in-browser ()
  "Open the bibtex entry at point in a browser using the url field or doi field"
(interactive)
(save-excursion
  (bibtex-beginning-of-entry)
  (catch 'done
    (let ((url (bibtex-autokey-get-field "url")))
      (when  url
        (browse-url url)
        (throw 'done nil)))

    (let ((doi (bibtex-autokey-get-field "doi")))
      (when doi
        (if (string-match "^http" doi)
            (browse-url doi)
          (browse-url (format "http://dx.doi.org/%s" doi)))
        (throw 'done nil)))
    (message "No url or doi found"))))
#+END_SRC

** citeulike
   I discovered you could upload a bibtex entry to citeulike using http requests. The upload is actually done by a [[*The%20upload%20script][python script]], because it was easy to write. Here is the emacs command to do this. It is not a fast operation, and  do not use it frequently.

*** function to upload bibtex to citeulike

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-upload-bibtex-entry-to-citeulike ()
  "with point in  a bibtex entry get bibtex string and submit to citeulike.

Relies on the python script /upload_bibtex_citeulike.py being in the user directory."
  (interactive)
  (message "uploading to citeulike")
  (save-restriction
    (bibtex-narrow-to-entry)
    (let ((startpos (point-min))
          (endpos (point-max))
          (bibtex-string (buffer-string))
          (script (concat "python " starter-kit-dir "/upload_bibtex_citeulike.py&")))
      (with-temp-buffer (insert bibtex-string)
                        (shell-command-on-region (point-min) (point-max) script t nil nil t)))))
#+END_SRC

*** The upload script
Here is the python script for uploading. 

*************** TODO document how to get the cookies
*************** END


#+BEGIN_SRC python :tangle upload_bibtex_citeulike.py
#!python
import pickle, requests, sys

# reload cookies
with open('c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/cookies.pckl', 'rb') as f:
    cookies = pickle.load(f)

url = 'http://www.citeulike.org/profile/jkitchin/import_do'

bibtex = sys.stdin.read()

data = {'pasted':bibtex,
        'to_read':2,
        'tag_parsing':'simple',
        'strip_brackets':'no',
        'update_id':'bib-key',
        'btn_bibtex':'Import BibTeX file ...'}

headers = {'content-type': 'multipart/form-data',
           'User-Agent':'jkitchin/johnrkitchin@gmail.com bibtexupload'}

r = requests.post(url, headers=headers, data=data, cookies=cookies, files={})
print r
#+END_SRC

** Build a pdf from a bibtex file
   It is useful to have a pdf version of an entire bibliography to check it for formatting, spelling, or to share it. This function creates a pdf from a bibtex file. I only include the packages  I commonly use in my bitex files.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-build-full-bibliography ()
  "build pdf of all bibtex entries, and open it."
  (interactive)
  (let* ((bibfile (file-name-nondirectory (buffer-file-name)))
	(bib-base (file-name-sans-extension bibfile))
	(texfile (concat bib-base ".tex"))
	(pdffile (concat bib-base ".pdf")))
    (find-file texfile)
    (erase-buffer)
    (insert (format "\\documentclass[12pt]{article}
\\usepackage[version=3]{mhchem}
\\usepackage{url}
\\usepackage[numbers]{natbib}
\\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, pdfstartview=FitH]{hyperref}
\\usepackage{doi}
\\begin{document}
\\nocite{*}
\\bibliographystyle{unsrtnat}
\\bibliography{%s}
\\end{document}" bib-base))
    (save-buffer)
    (shell-command (concat "pdflatex " bib-base))
    (shell-command (concat "bibtex " bib-base))
    (shell-command (concat "pdflatex " bib-base))
    (shell-command (concat "pdflatex " bib-base))
    (kill-buffer texfile)
    (org-open-file pdffile)
    )) 
#+END_SRC

** Extract bibtex entries cited in an org-file
When you use your default bibliography file, and you want to send an org-file to a collaborator, you may need to include bibtex entries so the other person can see them. This function does that and puts the entries in a section at the end of the document that can be tangled to a bib-file.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-extract-bibtex-entries ()
  "extract the bibtex entries referred to by cite links in the current buffer into a src block at the bottom of the current buffer.

If no bibliography is in the buffer the `reftex-default-bibliography' is used."
  (interactive)
  (let* ((tempname (make-temp-file "extract-bib"))
         (contents (buffer-string))
         (cb (current-buffer))
	 basename texfile bibfile results)
    
    ;; open tempfile and insert org-buffer contents
    (find-file tempname)
    (insert contents)
    (setq basename (file-name-sans-extension 
		    (file-name-nondirectory buffer-file-name))
	  texfile (concat tempname ".tex")
	  bibfile (concat tempname ".bib"))
    
    ;; see if we have a bibliography, and insert the default one if not.
    (save-excursion
      (goto-char (point-min))
      (unless (re-search-forward "^bibliography:" (point-max) 'end)
	(insert (format "\nbibliography:%s" 
			(mapconcat 'identity reftex-default-bibliography ",")))))
    (save-buffer)

    ;; get a latex file and extract the references
    (org-latex-export-to-latex)
    (find-file texfile)
    (reftex-parse-all)
    (reftex-create-bibtex-file bibfile)
    (save-buffer)
    ;; save results of the references
    (setq results (buffer-string))

    ;; kill buffers. these are named by basename, not full path
    (kill-buffer (concat basename ".bib"))
    (kill-buffer (concat basename ".tex"))
    (kill-buffer basename)

    (delete-file bibfile)
    (delete-file texfile)
    (delete-file tempname)

    ;; Now back to the original org buffer and insert the results
    (switch-to-buffer cb)
    (save-excursion
      (goto-char (point-max))
      (insert (format "

,** Bibtex entries

,#+BEGIN_SRC: :tangle %s
,%s
,#+END_SRC" bibfile results)))))
#+END_SRC

** Find bad cite links
Depending on how you enter citations, you may have citations with no corresponding bibtex entry. This function finds them and gives you a clickable table to navigate to them.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn 
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))


(defun org-ref-bib-find-bad-citations ()
  "Create a list of citation keys in an org-file that do not have a bibtex entry in the known bibtex files.

Makes a new buffer with clickable links."
  (interactive)
  ;; generate the list of bibtex-keys and cited keys
  (let* ((bibtex-files (org-ref-find-bibliography))
	 (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
	 (bad-citations '()))

    (org-element-map (org-element-parse-buffer) 'link
      (lambda (link)       
	(let ((plist (nth 1 link)))			     
	  (when (equal (plist-get plist ':type) "cite")
	    (dolist (key (org-ref-split-and-strip-string (plist-get plist ':path)) )
	      (when (not (index key bibtex-keys))
		(setq bad-citations (append bad-citations
					    `(,(format "%s [[elisp:(progn (switch-to-buffer-other-frame \"%s\")(goto-char %s))][not found here]]\n"
						       key (buffer-name)(plist-get plist ':begin)))))
		))))))

    (if identity bad-citations
      (progn
	(switch-to-buffer-other-window "*Missing citations*")
	(org-mode)
	(erase-buffer)
	(insert "* List of bad cite links\n")
	(insert (mapconcat 'identity bad-citations ""))
					;(setq buffer-read-only t)
	(use-local-map (copy-keymap org-mode-map))
	(local-set-key "q" #'(lambda () (interactive) (kill-buffer))))
      (message "No bad cite links found"))))
#+END_SRC

** Finding non-ascii characters
I like my bibtex files to be 100% ascii. This function finds the non-ascii characters so you can replace them. 

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-find-non-ascii-characters ()
  "finds non-ascii characters in the buffer. Useful for cleaning up bibtex files"
  (interactive)
  (occur "[^[:ascii:]]"))
#+END_SRC

* End of code
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(provide 'org-ref)
#+END_SRC


* Build								   :noexport:

[[elisp:(progn (org-babel-tangle) (load-file "org-ref.el"))]]

[[elisp:(org-babel-load-file "org-ref.org")]]
