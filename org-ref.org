#+TITLE: Org-ref - The best reference handling for org-mode
#+AUTHOR: John Kitchin
#+DATE: April 29, 2014

* Introduction

This document is an experiment at creating a literate program to provide similar features as reftex for org-mode referencing. These features include:

1. using completion to create links
2. storing links to places, 
3. Clickable links that do useful things
4. Exportable links to LaTeX
5. Utility functions for dealing with bibtex files and org-files


** Header
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
;;; org-ref.el --- setup bibliography, cite, ref and label org-mode links.

;; Copyright(C) 2014 John Kitchin

;; Author: John Kitchin <jkitchin@andrew.cmu.edu>
;; This file is not currently part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or (at
;; your option) any later version.

;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program ; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary:
;;
;; Lisp code to setup bibliography cite, ref and label org-mode links.
;; also sets up reftex for org-mode. The links are clickable and do
;; things that are useful. You should really read org-ref.org for details.
;;
;; Package-Requires: ((dash "2.6.0"))
#+END_SRC

** requires
The only external require is reftex-cite

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(require 'reftex-cite)
(require 'dash)
#+END_SRC

** Custom variables
There are some variables needed later to tell this library where you store your pdf files, where your notes file is, and your default bibliography. This variable is similar to the reftex-default-bibliography. I do not remember why I made it separate.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defgroup org-ref nil
  "customization group for org-ref")

(defcustom org-ref-bibliography-notes
  nil
  "filename to where you will put all your notes about an entry in
  the default bibliography."
  :type 'file
  :group 'org-ref)

(defcustom org-ref-default-bibliography
  nil
  "list of bibtex files to search for. You should use full-paths for each file."
  :type '(repeat :tag "List of bibtex files" file)
  :group 'org-ref)

(defcustom org-ref-pdf-directory
  nil
  "directory where pdfs are stored by key. put a trailing / in"
  :type 'directory
  :group 'org-ref)

(defcustom org-ref-default-citation-link
  "cite"
  "The default type of citation link to use"
  :type 'string
  :group 'org-ref)

(defcustom org-ref-insert-cite-key
  "C-c ]"
  "Keyboard shortcut to insert a citation."
  :type 'string
  :group 'org-ref)
#+END_SRC

This next variable determines the citation types that are available in org-ref. Links for each one are automatically generated, and completion functions are automatically generated. Users may add to this list in their own init files.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defcustom org-ref-cite-types
  '("cite" "autocite" "citealp" "citet" "citet*" "citep" "citep*" "citeauthor"
    "citeauthor*" "citeyear" "nocite" "citetext")
  "List of citation types known in org-ref"
  :type '(repeat :tag "List of citation types" string)
  :group 'org-ref)
#+END_SRC

** Program variables
#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defvar org-ref-bibliography-files
nil
"variable to hold bibliography files to be searched")
#+END_SRC
** org-mode / reftex setup

We setup reftex here. We use a custom insert cite link function defined here: [[*org-ref-insert-cite-link][org-ref-insert-cite-link]]. We setup reftex to use our org citation format.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-mode-reftex-setup ()
    (load-library "reftex")
    (and (buffer-file-name)
         (file-exists-p (buffer-file-name))
	 (global-auto-revert-mode t)
         (reftex-parse-all))
    (make-local-variable 'reftex-cite-format)
    (setq reftex-cite-format 'org)
    (define-key org-mode-map (kbd org-ref-insert-cite-key) 'org-ref-insert-cite-link))

(add-hook 'org-mode-hook 'org-mode-reftex-setup)

(eval-after-load 'reftex-vars
  '(progn
      (add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l")     ; default
			  (?d . ",%l")            ; for appending
			  (?a . "autocite:%l")
			  (?t . "citet:%l")
			  (?T . "citet*:%l")
			  (?p . "citep:%l")
			  (?P . "citep*:%l")
			  (?h . "citeauthor:%l")
			  (?H . "citeauthor*:%l")
			  (?y . "citeyear:%l")
			  (?x . "citetext:%l")
			  (?n . "nocite:%l")
			  )))))
#+END_SRC

You may want to add new formats to the reftex-cite-format-builtin variable. Here is an example of adding two new formats. Note that this does not create the links.

#+BEGIN_SRC emacs-lisp
;; add new format
(setf (nth 2 (assoc 'org reftex-cite-format-builtin))
      (append (nth 2 (assoc 'org reftex-cite-format-builtin)) '((?W  . "textcite:%l")
            (?z  . "newcite:%l"))))
#+END_SRC

* Links
Most of this library is the creation of functional links to help with references and citations.
** General utilities
We need several general utilities for this module. They are organized here. We frequently need to remove white space from the front and back of a string. Here we do that for a string.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-strip-string (string)
  "strip leading and trailing whitespace from the string"
  (interactive)
  (replace-regexp-in-string
   (concat search-whitespace-regexp "$" ) ""
   (replace-regexp-in-string
    (concat "^" search-whitespace-regexp ) "" string)))
#+END_SRC

It is helpful to make the previous function operate on a list of strings here.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-split-and-strip-string (string)
  "split key-string and strip keys. Assumes the key-string is comma delimited"
  (mapcar 'org-ref-strip-string (split-string string ",")))
#+END_SRC

** bibliography and bibliographystyle

We use a link for the bibliography so that we can click on it to open the bibliography file. The link may have more than one bibliography file in it, separated by commas. Clicking opens the file under the cursor. The bibliographies should be full filenames with the bib extension. Clicking on this link makes reftex-default-bibliography local and sets it to the list of files in the link. We need this to use reftex's searching capability.

*************** TODO biblatex support
3. I sometimes use biblatex instead of bibtex.  As a result, I do not
     use \bibliography and use \addbibresource instead.  I have
     defined my bibliography files in org-ref-default-bibliography but
     this is only picked up on initialisation.  It is difficult to
     update this for a document in progress (I had to locally set
     reftex-default-bibliography manually).
*************** END


#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(org-add-link-type "bibliography"
		   ;; this code is run on clicking. The bibliography
		   ;; may contain multiple files. this code finds the
		   ;; one you clicked on and opens it.
		   (lambda (link-string)	
		       ;; get link-string boundaries
		       ;; we have to go to the beginning of the line, and then search forward
		       
		     (let* ((bibfile)
			    ;; object is the link you clicked on
			    (object (org-element-context))
 
			    (link-string-beginning) 
			    (link-string-end))

		     (save-excursion
		       (goto-char (org-element-property :begin object))
		       (search-forward link-string nil nil 1)
		       (setq link-string-beginning (match-beginning 0))
		       (setq link-string-end (match-end 0)))

		       ;; We set the reftex-default-bibliography
		       ;; here. it should be a local variable only in
		       ;; the current buffer. We need this for using
		       ;; reftex to do citations.
		       (set (make-local-variable 'reftex-default-bibliography) 
			    (split-string (org-element-property :path object) ","))

		       ;; now if we have comma separated bibliographies
		       ;; we find the one clicked on. we want to
		       ;; search forward to next comma from point
		       (save-excursion
			 (if (search-forward "," link-string-end 1 1)
			     (setq key-end (- (match-end 0) 1)) ; we found a match
			   (setq key-end (point)))) ; no comma found so take the point
		       ;; and backward to previous comma from point
		       (save-excursion
			 (if (search-backward "," link-string-beginning 1 1)
			     (setq key-beginning (+ (match-beginning 0) 1)) ; we found a match
			   (setq key-beginning (point)))) ; no match found
		       ;; save the key we clicked on.
		       (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end)))
		       (message "found %s for bibliography" bibfile)
		       (find-file bibfile))) ; open file on click

		     ;; formatting code
		   (lambda (keyword desc format)
		     (cond
		      ((eq format 'html) (format "")); no output for html
		      ((eq format 'latex)
			 ;; write out the latex bibliography command
		       (format "\\bibliography{%s}" (replace-regexp-in-string  "\\.bib" "" keyword))))))
#+END_SRC

We also create a bibliographystyle link. There is nothing to do on clicking here, and we create it for consistency.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(org-add-link-type "bibliographystyle"
		   (lambda (arg) (message "Nothing implemented for clicking here."))
		   (lambda (keyword desc format)
		     (cond
		      ((eq format 'latex)
		       ;; write out the latex bibliography command
		       (format "\\bibliographystyle{%s}" keyword)))))
#+END_SRC

*** Completion for bibliography link
It would be nice 

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-bibliography-complete-link (&optional arg)
 (format "bibliography:%s" (read-file-name "enter file: " nil nil t)))

(defun org-ref-insert-bibliography-link ()
  "insert a bibliography with completion"
  (interactive)
  (insert (org-bibliography-complete-link)))
#+END_SRC

** addbibresource
This is apparently used for biblatex.
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(org-add-link-type "addbibresource"
		   ;; this code is run on clicking. The addbibresource
		   ;; may contain multiple files. this code finds the
		   ;; one you clicked on and opens it.
		   (lambda (link-string)	
		       ;; get link-string boundaries
		       ;; we have to go to the beginning of the line, and then search forward
		       
		     (let* ((bibfile)
			    ;; object is the link you clicked on
			    (object (org-element-context))
 
			    (link-string-beginning) 
			    (link-string-end))

		     (save-excursion
		       (goto-char (org-element-property :begin object))
		       (search-forward link-string nil nil 1)
		       (setq link-string-beginning (match-beginning 0))
		       (setq link-string-end (match-end 0)))

		       ;; We set the reftex-default-addbibresource
		       ;; here. it should be a local variable only in
		       ;; the current buffer. We need this for using
		       ;; reftex to do citations.
		       (set (make-local-variable 'reftex-default-addbibresource) 
			    (split-string (org-element-property :path object) ","))

		       ;; now if we have comma separated bibliographies
		       ;; we find the one clicked on. we want to
		       ;; search forward to next comma from point
		       (save-excursion
			 (if (search-forward "," link-string-end 1 1)
			     (setq key-end (- (match-end 0) 1)) ; we found a match
			   (setq key-end (point)))) ; no comma found so take the point
		       ;; and backward to previous comma from point
		       (save-excursion
			 (if (search-backward "," link-string-beginning 1 1)
			     (setq key-beginning (+ (match-beginning 0) 1)) ; we found a match
			   (setq key-beginning (point)))) ; no match found
		       ;; save the key we clicked on.
		       (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end)))
		       (message "found %s for addbibresource" bibfile)
		       (find-file bibfile))) ; open file on click

		     ;; formatting code
		   (lambda (keyword desc format)
		     (cond
		      ((eq format 'html) (format "")); no output for html
		      ((eq format 'latex)
			 ;; write out the latex addbibresource command
		       (format "\\addbibresource{%s}" (replace-regexp-in-string  "\\.bib" "" keyword))))))
#+END_SRC

** List of Figures

In long documents, a list of figures is not uncommon. Here we create a clickable link that generates a temporary buffer containing a list of figures in the document, and their captions. We make a function that can be called interactively, and define a link type that is rendered in LaTeX to create the list of figures.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-list-of-figures (&optional arg)
  "Generate buffer with list of figures in them"
  (interactive)
  (let* ((c-b (buffer-name))
	 (counter 0)
	 (list-of-figures 
	  (org-element-map (org-element-parse-buffer) 'link
	    (lambda (link) 
	      "create a link for to the figure"
	      (when 
		  (and (string= (org-element-property :type link) "file")
		       (string-match-p  
			"[^.]*\\.\\(png\\|jpg\\|eps\\|pdf\\)$"
			(org-element-property :path link)))                   
		(incf counter)
		
		(let* ((start (org-element-property :begin link))
		       (parent (car (cdr (org-element-property :parent link))))
		       (caption (caaar (plist-get parent :caption)))
		       (name (plist-get parent :name)))
		  (if caption 
		      (format 
		       "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]] %s\n" 
		       c-b start counter (or name "") caption)
		    (format 
		     "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]]\n" 
		     c-b start counter (or name "")))))))))
    (switch-to-buffer "*List of Figures*")
    (org-mode)
    (erase-buffer)
    (insert (mapconcat 'identity list-of-figures ""))
    (setq buffer-read-only t)
    (use-local-map (copy-keymap org-mode-map))
    (local-set-key "q" #'(lambda () (interactive) (kill-buffer)))))

(org-add-link-type 
 "list-of-figures"
 'org-ref-list-of-figures ; on click
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\listoffigures")))))
#+END_SRC

** List of Tables

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-list-of-tables (&optional arg)
  "Generate a buffer with a list of tables"
  (interactive)
  (let* ((c-b (buffer-name))
	 (counter 0)
	 (list-of-tables 
	  (org-element-map (org-element-parse-buffer 'element) 'table
	    (lambda (table) 
	      "create a link for to the table"
	      (incf counter)
	      (let ((start (org-element-property :begin table))
		    (name  (org-element-property :name table))
		    (caption (caaar (org-element-property :caption table))))
		(if caption 
		    (format 
		     "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]] %s\n" 
		     c-b start counter (or name "") caption)
		  (format 
		   "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]]\n" 
		   c-b start counter (or name ""))))))))
    (switch-to-buffer "*List of Tables*")
    (org-mode)
    (erase-buffer)
    (insert (mapconcat 'identity list-of-tables ""))
    (setq buffer-read-only t)
    (use-local-map (copy-keymap org-mode-map))
    (local-set-key "q" #'(lambda () (interactive) (kill-buffer)))))

(org-add-link-type 
 "list-of-tables"
 'org-ref-list-of-tables
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\listoftables")))))
#+END_SRC
** label

The label link provides a way to create labels in org-mode. We make it clickable because we want to make sure labels are unique. This code will tell you how many instances of a label are found.  We search for label links, LaTeX labels, and the org-mode format for labels. We probably should search for tblnames too.
*************** TODO search tblnames, custom_ids and check for case sensitivity
*************** END

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(org-add-link-type
 "label"
 (lambda (label)
   "on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels!"
   (message (format "%s occurences"
		    (+ (count-matches (format "label:%s\\b" label) (point-min) (point-max) t)
		       (count-matches (format "\\label{%s}\\b" label) (point-min) (point-max) t)
                       ;; this is the org-format #+label:
		       (count-matches (format "#\\+label:%s\\b" label) (point-min) (point-max) t)))))
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<label>%s</label>)" path))
    ((eq format 'latex)
     (format "\\label{%s}" keyword)))))
#+END_SRC

We want to store links on labels, so you can put the cursor on the label, press C-c l, and later use C-c C-l to insert a link to the label. We also want to store links to tables with a table name, and for sections with CUSTOM_ID.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-label-store-link ()
  "store a link to a label. The output will be a ref to that label"
  ;; First we have to make sure we are on a label link. 
  (let* ((object (org-element-context)))
    (when (and (equal (org-element-type object) 'link) 
               (equal (org-element-property :type object) "label"))
      (org-store-link-props
       :type "ref"
       :link (concat "ref:" (org-element-property :path object))))

    ;; Store link on table
    (when (equal (org-element-type object) 'table)
      (org-store-link-props
       :type "ref"
       :link (concat "ref:" (org-element-property :name object))))

;; it turns out this does not work. you can already store a link to a heading with a CUSTOM_ID
    ;; store link on heading with custom_id
;    (when (and (equal (org-element-type object) 'headline)
;	       (org-entry-get (point) "CUSTOM_ID"))
;      (org-store-link-props
;       :type "ref"
;       :link (concat "ref:" (org-entry-get (point) "CUSTOM_ID"))))

    ;; and to #+label: lines
    (when (and (equal (org-element-type object) 'paragraph)
	       (org-element-property :name object))
      (org-store-link-props
       :type "ref"
       :link (concat "ref:" (org-element-property :name object))))
))

(add-hook 'org-store-link-functions 'org-label-store-link)
#+END_SRC
** ref

The ref link allows you make links to labels. Clicking on the link takes you to the label, and provides a mark to go back to. 

At the moment, ref links are not usable for section links. You need [[#CUSTOM_ID]] type links.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(org-add-link-type
 "ref"
 (lambda (label)
   "on clicking goto the label. Navigate back with C-c &"
   (org-mark-ring-push)
   ;; next search from beginning of the buffer

   (unless
       (or
	;; our label links
	(progn 
	  (goto-char (point-min))
	  (re-search-forward (format "label:%s\\b" label) nil t))

	;; a latex label
	(progn
	  (goto-char (point-min))
	  (re-search-forward (format "\\label{%s}" label) nil t))

	;; #+label: name  org-definition
	(progn
	  (goto-char (point-min))
	  (re-search-forward (format "^#\\+label:\\s-*\\(%s\\)\\b" label) nil t))
	
	;; org tblname
	(progn
	  (goto-char (point-min))
	  (re-search-forward (format "^#\\+tblname:\\s-*\\(%s\\)\\b" label) nil t))

;; Commented out because these ref links do not actually translate correctly in LaTeX.
;; you need [[#label]] links.
	;; CUSTOM_ID
;	(progn
;	  (goto-char (point-min))
;	  (re-search-forward (format ":CUSTOM_ID:\s-*\\(%s\\)" label) nil t))
	)
     ;; we did not find anything, so go back to where we came
     (org-mark-ring-goto)
     (error "%s not found" label))
   (message "go back with (org-mark-ring-goto) `C-c &`"))
 ;formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<ref>%s</ref>)" path))
    ((eq format 'latex)
     (format "\\ref{%s}" keyword)))))
#+END_SRC

It would be nice to use completion to enter a ref link, where a list of labels is provided. The following code searches the buffer for labels, custom_ids, and table names as potential items to make a ref link to.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-get-custom-ids ()
 "return a list of custom_id properties in the buffer"
 (interactive)
 (let ((results '()) custom_id)
   (org-map-entries 
    (lambda () 
      (let ((custom_id (org-entry-get (point) "CUSTOM_ID")))
	(when (not (null custom_id))
	  (setq results (append results (list custom_id)))))))
results))
#+END_SRC

Here we get a list of the labels defined as raw latex labels, e.g. \label{eqtre}.
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-get-latex-labels ()
(interactive) 
(save-excursion
    (goto-char (point-min))
    (let ((matches '()))
      (while (re-search-forward "\\\\label{\\([a-zA-z0-9:-]*\\)}" (point-max) t)
	(add-to-list 'matches (match-string-no-properties 1) t))
matches)))
#+END_SRC

Finally, we get the table names.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-get-tblnames ()
  (interactive)
  (org-element-map (org-element-parse-buffer 'element) 'table
    (lambda (table) 
      (org-element-property :name table))))
#+END_SRC

Now, we can put all the labels together which will give us a list of candidates.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-get-labels ()
  "returns a list of labels in the buffer that you can make a ref link to. this is used to auto-complete ref links."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((matches '()))
      (while (re-search-forward "label:\\([a-zA-z0-9:-]*\\)" (point-max) t)
	(add-to-list 'matches (match-string-no-properties 1) t))
      (append matches (org-ref-get-latex-labels) (org-ref-get-tblnames) (org-ref-get-custom-ids)))))
#+END_SRC

Now we create the completion function. This works from the org-machinery, e.g. if you type C-c C-l to insert a link, and use completion by pressing tab.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-complete-link (&optional arg)
  "Completion function for ref links"
  (let ((label))
    (setq label (completing-read "label: " (org-ref-get-labels)))
    (format "ref:%s" label)))
#+END_SRC

Alternatively, you may want to just call a function that inserts a link with completion:

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-insert-ref-link ()
 (interactive)
 (insert (org-ref-complete-link)))
#+END_SRC

** eqref
This is just the LaTeX ref for equations. On export, the reference is enclosed in parentheses.
 
#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(org-add-link-type
 "eqref"
 (lambda (label)
   "on clicking goto the label. Navigate back with C-c &"
   (org-mark-ring-push)
   ;; next search from beginning of the buffer
   (goto-char (point-min))
   (unless
       (or
	;; search forward for the first match
	;; our label links
	(re-search-forward (format "label:%s" label) nil t)
	;; a latex label
	(re-search-forward (format "\\label{%s}" label) nil t)
	;; #+label: name  org-definition
	(re-search-forward (format "^#\\+label:\\s-*\\(%s\\)\\b" label) nil t))
     (org-mark-ring-goto)
     (error "%s not found" label))
   (message "go back with (org-mark-ring-goto) `C-c &`"))
 ;formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<eqref>%s</eqref>)" path))
    ((eq format 'latex)
     (format "\\eqref{%s}" keyword)))))
#+END_SRC

** cite
This is the main reason this library exists. We want the following behavior. A cite link should be able to contain multiple bibtex keys. You should be able to click on the link, and get a brief citation of the entry for that key, and a menu of options to open the bibtex file, open a pdf if you have it, open your notes on the entry, or open a url if it exists. You should be able to insert new references onto an existing cite link, or create new ones easily. The following code implements these features.

*** Implementing the click actions of cite

**** Getting the key we clicked on
The first thing we need is to get the bibtex key we clicked on.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-get-bibtex-key-under-cursor ()
  "returns key under the bibtex cursor. We search forward from
point to get a comma, or the end of the link, and then backwards
to get a comma, or the beginning of the link. that delimits the
keyword we clicked on. We also strip the text properties."
  (interactive)
  (let* ((object (org-element-context))	 
	 (link-string (org-element-property :path object)))    
    
    ;; we need the link path start and end
    (save-excursion
      (goto-char (org-element-property :begin object))
      (search-forward link-string nil nil 1)
      (setq link-string-beginning (match-beginning 0))
      (setq link-string-end (match-end 0)))

    ;; The key is the text between commas, or the link boundaries
    (save-excursion
      (if (search-forward "," link-string-end t 1)
	  (setq key-end (- (match-end 0) 1)) ; we found a match
	(setq key-end link-string-end))) ; no comma found so take the end
    ;; and backward to previous comma from point which defines the start character
    (save-excursion
      (if (search-backward "," link-string-beginning 1 1)
	  (setq key-beginning (+ (match-beginning 0) 1)) ; we found a match
	(setq key-beginning link-string-beginning))) ; no match found
    ;; save the key we clicked on.
    (setq bibtex-key (org-ref-strip-string (buffer-substring key-beginning key-end)))
    (set-text-properties 0 (length bibtex-key) nil bibtex-key)
    (message "you selected %s" bibtex-key)
    bibtex-key
    ))
#+END_SRC

We also need to find which bibliography file that key is in. For that, we need to know which bibliography files are referred to in the file. If none are specified with a bibliography link, we use the default bibliography. This function searches for a bibliography link, and then the LaTeX bibliography link. We also consider the addbibresource link which is used with biblatex.

**** Getting the bibliographies
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-find-bibliography ()
  "find the bibliography in the buffer.
This function sets and returns cite-bibliography-files, which is a list of files
either from bibliography:f1.bib,f2.bib
\bibliography{f1,f2}
internal bibliographies

falling back to what the user has set in org-ref-default-bibliography
"
  (interactive)
  (catch 'result
    (save-excursion
      (goto-char (point-min))
      ;;  look for a bibliography link
      (when (re-search-forward "bibliography:\\([^\]\|\n]+\\)" nil t)      	
	(setq org-ref-bibliography-files
	      (mapcar 'org-ref-strip-string (split-string (match-string 1) ",")))
	(message "bibliography org-ref-bibliography-files = %s from %s" org-ref-bibliography-files (match-string 1))
	(throw 'result org-ref-bibliography-files))

      
      ;; we did not find a bibliography link. now look for \bibliography
      (message "no bibliography link found")
      (goto-char (point-min))
      (when (re-search-forward "\\\\bibliography{\\([^}]+\\)}" nil t)
	;; split, and add .bib to each file
	(setq org-ref-bibliography-files
	      (mapcar (lambda (x) (concat x ".bib"))
		      (mapcar 'org-ref-strip-string 
			      (split-string (match-string 1) ","))))
	(message "\\bibliography org-ref-bibliography-files = %s from %s" org-ref-bibliography-files (match-string 1))
	(throw 'result org-ref-bibliography-files))

      ;; no bibliography found. maybe we need a biblatex addbibresource
      (goto-char (point-min))
      ;;  look for a bibliography link
      (when (re-search-forward "addbibresource:\\([^\]\|\n]+\\)" nil t)
	(setq org-ref-bibliography-files
	      (mapcar 'org-ref-strip-string (split-string (match-string 1) ",")))
	(message "addbibresource org-ref-bibliography-files = %s from %s" org-ref-bibliography-files (match-string 1))
	(throw 'result org-ref-bibliography-files))
	  
      ;; we did not find anything. use defaults
      (setq org-ref-bibliography-files org-ref-default-bibliography)
      (message "org-ref-bibliography-files = %s from defaults" org-ref-bibliography-files)))

    (message "finally: org-ref-bibliography-files = %s" org-ref-bibliography-files)
    ;; set reftex-default-bibliography so we can search
    (set (make-local-variable 'reftex-default-bibliography) org-ref-bibliography-files)
    org-ref-bibliography-files)
#+END_SRC

**** Finding the bibliography file a key is in
Now, we can see if an entry is in a file. 

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-key-in-file-p (key filename)
  "determine if the key is in the file"
  (interactive "skey: \nsFile: ")

  (let ((cb (current-buffer)))
    (set-buffer (find-file-noselect filename))
    (prog1 
	(bibtex-search-entry key nil 0)
      (set-buffer cb))))
#+END_SRC

Finally, we want to know which file the key is in.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-get-bibtex-key-and-file ()
  "returns the bibtex key and file that it is in under point"
 (interactive)

 (let ((org-ref-bibliography-files (org-ref-find-bibliography))
       (key) (file))
   (setq key (org-ref-get-bibtex-key-under-cursor))
   (setq file     (catch 'result
		    (loop for file in org-ref-bibliography-files do
			  (message "looking for %s in %s" key file)
			  (if (org-ref-key-in-file-p key (file-truename file)) 
			      (throw 'result file)
			    (message "%s not found in %s" key (file-truename file))))))
   (message  "you found %s in %s" key file)
   (cons key file)))
#+END_SRC

**** Creating the menu for when we click on a key
When we click on a cite link, we want to get a menu in the minibuffer. We need to create a string for this. We want a citation, and some options that depend on the key. We want to know if the key is found, if there is a pdf, if etc... Here we create that string.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-get-menu-options ()
  "returns a dynamically determined string of options for the citation under point.

we check to see if there is pdf, and if the key actually exists in the bibliography"
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat org-ref-pdf-directory "%s.pdf") key))
         (bibfile (cdr results))
	 m1 m2 m3 m4 m5 menu-string)
    (setq m1 (if bibfile		 
		 "(o)pen"
	       "(No key found)"))

    (setq m3 (if (file-exists-p pdf-file)
		 "(p)df"
		     "(No pdf found)"))

    (setq m4 (if (not (string= (catch 'url
				 (progn
				   (set-buffer (find-file-noselect bibfile))
				   (bibtex-search-entry key)
				   (when (setq url (bibtex-autokey-get-field "url"))
				     (throw 'url url))
				   
				   (when (setq url (bibtex-autokey-get-field "doi"))
				     (throw 'url url)))) ""))
		 "(u)rl" "(no url found)"))
    (set-buffer cb)
    (setq m5 "(n)otes")
    (setq m2 (if bibfile
		 (progn
		   (let ((cb (current-buffer)) citation)
		     (setq citation (progn
				      (set-buffer (find-file-noselect bibfile))
				      (bibtex-search-entry key)  
				      (org-ref-bib-citation)))
		     (set-buffer cb)
		     citation))
	       "no key found"))

    (setq menu-string (mapconcat 'identity (list m2 "\n" m1 m3 m4 m5 "(q)uit") "  "))
    (message "%s" menu-string)
    menu-string))
#+END_SRC

**** convenience functions to act on citation at point
We need some convenience functions to open act on the citation at point. These will get the pdf, open the url, or open the notes.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-open-pdf-at-point ()
  "open the pdf for bibtex key under point if it exists"
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
         (pdf-file (format (concat org-ref-pdf-directory "%s.pdf") key)))
    (if (file-exists-p pdf-file)
	(org-open-file pdf-file)
(message "no pdf found for %s" key))))


(defun org-ref-open-url-at-point ()
  "open the url for bibtex key under point."
  (interactive)
  (let* ((cb (current-buffer))
	 (results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
	 (bibfile (cdr results)))
    (save-excursion
      (set-buffer (find-file-noselect bibfile))
      (bibtex-search-entry key)
      ;; I like this better than bibtex-url which does not always find
      ;; the urls
      (catch 'done
	(let ((url (bibtex-autokey-get-field "url")))
	  (when  url
	    (browse-url url)
	    (throw 'done nil)))

	(let ((doi (bibtex-autokey-get-field "doi")))
	  (when doi
	    (if (string-match "^http" doi)
		(browse-url doi)
	      (browse-url (format "http://dx.doi.org/%s" doi)))
	    (throw 'done nil)))))
    (set-buffer cb)))


(defun org-ref-open-notes-at-point ()
  "open the notes for bibtex key under point."
  (interactive)
  (let* ((cb (current-buffer))
	 (results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
	 (bibfile (cdr results)))
    (save-excursion
	   (find-file bibfile)
	   (bibtex-search-entry key)
	   (org-ref-open-bibtex-notes))))

(defun org-ref-citation-at-point ()
  "give message of current citation at point"
  (interactive)
  (let* ((cb (current-buffer))
	(results (org-ref-get-bibtex-key-and-file))
	(key (car results))
	(bibfile (cdr results)))	
    (message "%s" (progn
		    (set-buffer (find-file-noselect bibfile))
		    (bibtex-search-entry key)  
		    (org-ref-bib-citation)))
    (set-buffer cb)))

(defun org-ref-open-citation-at-point ()
  "open bibtex file to key at point"
  (interactive)
  (let* ((cb (current-buffer))
	(results (org-ref-get-bibtex-key-and-file))
	(key (car results))
	(bibfile (cdr results)))
    (find-file bibfile)
    (bibtex-search-entry key)))
#+END_SRC

**** the actual minibuffer menu
Now, we create the menu.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-cite-onclick-minibuffer-menu (&optional link-string)
  "use a minibuffer to select options for the citation under point.

you select your option with a single key press."
  (interactive)
  (let* ((choice (read-char (org-ref-get-menu-options)))
	 (results (org-ref-get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat org-ref-pdf-directory "%s.pdf") key))
         (bibfile (cdr results)))

    (cond
     ;; open
     ((= choice ?o)
      (find-file bibfile)
       (bibtex-search-entry key))

     ;; cite
     ((= choice ?c)
      (org-ref-citation-at-point))
      

     ;; quit
     ((or 
      (= choice ?q) ; q
      (= choice ?\ )) ; space
      ;; this clears the minibuffer
      (message ""))

     ;; pdf
     ((= choice ?p)
      (org-ref-open-pdf-at-point))

     ;; notes
     ((= choice ?n)
      (org-ref-open-notes-at-point))

     ;; url
     ((= choice ?u)
      (org-ref-open-url-at-point))

     ;; anything else we just quit.
     (t (message "")))))
    
#+END_SRC

*** A function to format a cite link
Next, we define a formatting function for the cite link. This is done so that the cite link definition is very short, and easy to change. You just need to specify the functions in the definition.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-cite-link-format (keyword desc format)
   (cond
    ((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
     (concat "\\cite" (when desc (format "[%s]" desc)) "{"
	     (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
	     "}"))))
#+END_SRC

*** The actual cite link
Finally, we define the cite link.

*************** TODO format content to get \cite[content]{path}
*************** END

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(org-add-link-type
 "cite"
 'org-ref-cite-onclick-minibuffer-menu
 'org-ref-cite-link-format)
#+END_SRC

*** Miscellaneous cite link variations				   :noexport:
I do not use these alot, but they are variations of the regular cite commands in LaTeX. For a good reference on what these do see http://merkel.zoneo.net/Latex/natbib.php. The citet variants are for textual citations, and the citep variants are parenthetical citations. What you actually get seems to depend on the bibliography style you are using.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(org-add-link-type
 "autocite"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<autocite>%s</autocite>)" path))
    ((eq format 'latex)
     (concat "\\autocite{"
	     (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
	     "}")))))


(org-add-link-type
 "citealp"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<citealp>%s</citealp>)" path))
    ((eq format 'latex)
     (concat "\\citealp{"
	     (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
	     "}")))))

(org-add-link-type
 "citet"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citet{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citet*"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citet*{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

;; TODO these links do not support options [see][]
(org-add-link-type
 "citep"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citep{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citep*"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citep*{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citeauthor"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citeauthor{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citeauthor*"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citeauthor*{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citeyear"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citeyear{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "nocite"
 'org-ref-cite-onclick-minibuffer-menu
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\nocite{" (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",") "}")))))

(org-add-link-type
 "citetext"
 nil ;; clicking does not make sense
 ;; formatting
 (lambda (keyword desc format)
   (cond
((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
  (concat "\\citetext{" path "}")))))
#+END_SRC

*** Automatic definition of the cite links
There are many different kinds of citations in LaTeX, but they are all variants of a basic syntax of \citetype[optional text]{label1,label2}. Here we use lisp to generate the link definitions. We define a function that creates the code to create the link, and then we evaluate it. We also create the completion function for the new link, and add it to the list of known links. 

#+BEGIN_SRC emacs-lisp :tangle org-ref.el 
(defmacro org-ref-make-completion-function (type)
  `(defun ,(intern (format "org-%s-complete-link" type)) (&optional arg)
     (interactive)
     (format "%s:%s" 
	     ,type
	     (completing-read 
	      "bibtex key: " 
	      (let ((bibtex-files (org-ref-find-bibliography)))
		(bibtex-global-key-alist))))))
#+END_SRC

We create the links by mapping the function onto the list of defined link types.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-define-citation-link (type &optional key)
  "add a citation link for org-ref. With optional key, set the reftex binding. For example:
(org-ref-define-citation-link \"citez\" ?z) will create a new citez link, with reftex key of z, 
and the completion function."
  (interactive "sCitation Type: \ncKey: ")
  (eval-expression 
   `(org-add-link-type 
     ,type
     'org-ref-cite-onclick-minibuffer-menu

     ;; formatting
     (lambda (keyword desc format)
       (cond
	((eq format 'html) (format "(<",type">%s</",type">)" path))
	((eq format 'latex)
	 (concat "\\" ,type (when desc (format "[%s]" desc)) "{"
		 (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
		 "}"))))))

  ;; create the completion function
  (eval `(org-ref-make-completion-function ,type))

  ;; store new type so it works with adding citations, which checks
  ;; for existence in this list
  (add-to-list 'org-ref-cite-types type)

  ;; and finally if a key is specified, we modify the reftex menu
  (when key
    (setf (nth 2 (assoc 'org reftex-cite-format-builtin))
	  (append (nth 2 (assoc 'org reftex-cite-format-builtin)) 
		  `((,key  . ,(concat type ":%l")))))))

;; create all the link types and their completion functions
(mapcar 'org-ref-define-citation-link org-ref-cite-types)
#+END_SRC

*** org-ref-insert-cite-link
We need a convenient method to insert links. In reftex you use the keystroke C-c ], which gives you a minibuffer to search the bibtex files from. This function is bound to that same keystroke here [[*org-mode%20/%20reftex%20setup][org-mode / reftex setup]]. This function will append to a cite link if you call it while on a link.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-insert-cite-link (alternative-cite)
  "Insert a default citation link using reftex. If you are on a link, it
appends to the end of the link, otherwise, a new link is
inserted. Use a prefix arg to get a menu of citation types."
  (interactive "P")
  (let* ((object (org-element-context))
	 (link-string-beginning (org-element-property :begin object))
	 (link-string-end (org-element-property :end object))
	 (path (org-element-property :path object)))  

    (if (not alternative-cite)
	
	(cond
	 ;; case where we are in a link
	 ((and (equal (org-element-type object) 'link) 
	       (-contains? org-ref-cite-types (org-element-property :type object)))
	  (goto-char link-string-end)
	  ;; sometimes there are spaces at the end of the link
	  ;; this code moves point pack until no spaces are there
	  (while (looking-back " ") (backward-char))  
	  (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))

	 ;; We are next to a link, and we want to append
	 ((save-excursion 
	    (backward-char)
	    (and (equal (org-element-type (org-element-context)) 'link) 
		 (-contains? org-ref-cite-types (org-element-property :type (org-element-context)))))
	  (while (looking-back " ") (backward-char))  
	  (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))

	 ;; insert fresh link
	 (t 
	  (insert 
	   (concat org-ref-default-citation-link 
		   ":" 
		   (mapconcat 'identity (reftex-citation t) ",")))))

      ;; you pressed a C-u so we run this code
      (reftex-citation)))
  )
#+END_SRC

#+RESULTS:
: org-ref-insert-cite-link

*** Completion in cite links
If you know the specific bibtex key, you may like to use completion directly. You use this with the org-mode machinery and tab completion. Here is the prototypical completion function. These are now all created when the links are created.

#+BEGIN_SRC emacs-lisp  
(defun org-cite-complete-link (&optional arg)
  "Completion function for cite links"
  (format "%s:%s" 
          org-ref-default-citation-link
	  (completing-read 
	   "bibtex key: " 
	   (let ((bibtex-files (org-ref-find-bibliography)))
	     (bibtex-global-key-alist)))))
#+END_SRC

Alternatively, you may shortcut the org-machinery with this command. You will be prompted for a citation type, and then offered key completion.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-insert-cite-with-completion (type)
  "Insert a cite link with completion"
  (interactive (list (ido-completing-read "Type: " org-ref-cite-types)))
  (insert (funcall (intern (format "org-%s-complete-link" type)))))
#+END_SRC

*** Storing links to a bibtex entry
org-mode already defines a store link function for bibtex entries. It does not store the link I want though, it only stores a brief citation of the entry. I want a citation link. Here is a function to do that.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-store-bibtex-entry-link ()
  "Save a citation link to the current bibtex entry. Saves in the default link type."
  (interactive)
  (let ((link (concat org-ref-default-citation-link 
		 ":"   
		 (save-excursion
		   (bibtex-beginning-of-entry)
		   (reftex-get-bib-field "=key=" (bibtex-parse-entry))))))
    (message "saved %s" link)
    (push (list link) org-stored-links)
    (car org-stored-links)))
#+END_SRC

* Utilities
** create simple text citation from bibtex entry

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-bib-citation ()
  "from a bibtex entry, create and return a simple citation string."
  (interactive)
  (if (eq major-mode 'bibtex-mode)
      (progn
        (bibtex-beginning-of-entry)
        (let* ((cb (current-buffer))
               (bibtex-expand-strings t)
               (entry (bibtex-parse-entry t))
               (title (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "title" entry)))
               (year  (reftex-get-bib-field "year" entry))
               (author (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "author" entry)))
               (key (reftex-get-bib-field "=key=" entry))
               (journal (reftex-get-bib-field "journal" entry))
               (volume (reftex-get-bib-field "volume" entry))
               (pages (reftex-get-bib-field "pages" entry))
               (doi (reftex-get-bib-field "doi" entry))
               (url (reftex-get-bib-field "url" entry))
               )
	  ;;authors, "title", Journal, vol(iss):pages (year).
            (format "%s, \"%s\", %s, %s:%s (%s)"
		    author title journal  volume pages year)))))
#+END_SRC

** open pdf from bibtex
We find this to a key here: [[*key%20bindings%20for%20utilities][key bindings for utilities]].
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-open-bibtex-pdf ()
  "open pdf for a bibtex entry, if it exists. assumes point is in
the entry of interest in the bibfile. but does not check that."
  (interactive)
  (save-excursion
    (bibtex-beginning-of-entry)
    (let* ((bibtex-expand-strings t)
           (entry (bibtex-parse-entry t))
           (key (reftex-get-bib-field "=key=" entry))
           (pdf (format (concat org-ref-pdf-directory "%s.pdf") key)))
      (message "%s" pdf)
      (if (file-exists-p pdf)
          (org-open-link-from-string (format "[[file:%s]]" pdf))
        (ding)))))
#+END_SRC

** open notes from bibtex
We bind this to a key here [[*key%20bindings%20for%20utilities][key bindings for utilities]].

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-open-bibtex-notes ()
  "from a bibtex entry, open the notes if they exist, and create a heading if they do not.

I never did figure out how to use reftex to make this happen
non-interactively. the reftex-format-citation function did not
work perfectly; there were carriage returns in the strings, and
it did not put the key where it needed to be. so, below I replace
the carriage returns and extra spaces with a single space and
construct the heading by hand."
  (interactive)
  (if (eq major-mode 'bibtex-mode)
      (progn
        (bibtex-beginning-of-entry)
        (let* ((cb (current-buffer))
               (bibtex-expand-strings t)
               (entry (bibtex-parse-entry t))
               (title (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "title" entry)))
               (year  (reftex-get-bib-field "year" entry))
               (author (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "author" entry)))
               (key (reftex-get-bib-field "=key=" entry))
               (journal (reftex-get-bib-field "journal" entry))
               (volume (reftex-get-bib-field "volume" entry))
               (pages (reftex-get-bib-field "pages" entry))
               (doi (reftex-get-bib-field "doi" entry))
               (url (reftex-get-bib-field "url" entry))
               )
	  (save-buffer)

	  ;; save key to clipboard to make saving pdf later easier by pasting.
	  (with-temp-buffer
	    (insert key)
	    (kill-ring-save (point-min) (point-max)))

          ;; now look for entry in the notes file
          (if  org-ref-bibliography-notes
	      (find-file org-ref-bibliography-notes)
	    (error "org-ref-bib-bibliography-notes is not set to anything"))

          (goto-char (point-min))
          ;; put new entry in notes if we don't find it.
          (unless (re-search-forward (format ":Custom_ID: %s$" key) nil 'end)
            (insert (format "\n** TODO %s - %s" year title))
            (insert (format"
 :PROPERTIES:
  :Custom_ID: %s
  :AUTHOR: %s
  :JOURNAL: %s
  :YEAR: %s
  :VOLUME: %s
  :PAGES: %s
  :DOI: %s
  :URL: %s
 :END:
[[cite:%s]] [[file:%s/%s.pdf][pdf]]\n\n"
key author journal year volume pages doi url key org-ref-pdf-directory key))
(save-buffer))))))
#+END_SRC

** open url in browser from bibtex

We bind this to a key here [[*key%20bindings%20for%20utilities][key bindings for utilities]].

+ This function may be duplicative of bibtex-url. But I think my function is better unless you do some complicated customization of bibtex-generate-url-list.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-open-in-browser ()
  "Open the bibtex entry at point in a browser using the url field or doi field"
(interactive)
(save-excursion
  (bibtex-beginning-of-entry)
  (catch 'done
    (let ((url (bibtex-autokey-get-field "url")))
      (when  url
        (browse-url url)
        (throw 'done nil)))

    (let ((doi (bibtex-autokey-get-field "doi")))
      (when doi
        (if (string-match "^http" doi)
            (browse-url doi)
          (browse-url (format "http://dx.doi.org/%s" doi)))
        (throw 'done nil)))
    (message "No url or doi found"))))
#+END_SRC

** citeulike
   I discovered you could upload a bibtex entry to citeulike using http requests. The upload is actually done by a [[*The%20upload%20script][python script]], because it was easy to write. Here is the emacs command to do this. It is not a fast operation, and  do not use it frequently.

*** function to upload bibtex to citeulike

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-upload-bibtex-entry-to-citeulike ()
  "with point in  a bibtex entry get bibtex string and submit to citeulike.

Relies on the python script /upload_bibtex_citeulike.py being in the user directory."
  (interactive)
  (message "uploading to citeulike")
  (save-restriction
    (bibtex-narrow-to-entry)
    (let ((startpos (point-min))
          (endpos (point-max))
          (bibtex-string (buffer-string))
          (script (concat "python " starter-kit-dir "/upload_bibtex_citeulike.py&")))
      (with-temp-buffer (insert bibtex-string)
                        (shell-command-on-region (point-min) (point-max) script t nil nil t)))))
#+END_SRC

*** The upload script
Here is the python script for uploading. 

*************** TODO document how to get the cookies
*************** END


#+BEGIN_SRC python :tangle upload_bibtex_citeulike.py
#!python
import pickle, requests, sys

# reload cookies
with open('c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/cookies.pckl', 'rb') as f:
    cookies = pickle.load(f)

url = 'http://www.citeulike.org/profile/jkitchin/import_do'

bibtex = sys.stdin.read()

data = {'pasted':bibtex,
        'to_read':2,
        'tag_parsing':'simple',
        'strip_brackets':'no',
        'update_id':'bib-key',
        'btn_bibtex':'Import BibTeX file ...'}

headers = {'content-type': 'multipart/form-data',
           'User-Agent':'jkitchin/johnrkitchin@gmail.com bibtexupload'}

r = requests.post(url, headers=headers, data=data, cookies=cookies, files={})
print r
#+END_SRC

** Build a pdf from a bibtex file
   It is useful to have a pdf version of an entire bibliography to check it for formatting, spelling, or to share it. This function creates a pdf from a bibtex file. I only include the packages  I commonly use in my bitex files.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-build-full-bibliography ()
  "build pdf of all bibtex entries, and open it."
  (interactive)
  (let* ((bibfile (file-name-nondirectory (buffer-file-name)))
	(bib-base (file-name-sans-extension bibfile))
	(texfile (concat bib-base ".tex"))
	(pdffile (concat bib-base ".pdf")))
    (find-file texfile)
    (erase-buffer)
    (insert (format "\\documentclass[12pt]{article}
\\usepackage[version=3]{mhchem}
\\usepackage{url}
\\usepackage[numbers]{natbib}
\\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, pdfstartview=FitH]{hyperref}
\\usepackage{doi}
\\begin{document}
\\nocite{*}
\\bibliographystyle{unsrtnat}
\\bibliography{%s}
\\end{document}" bib-base))
    (save-buffer)
    (shell-command (concat "pdflatex " bib-base))
    (shell-command (concat "bibtex " bib-base))
    (shell-command (concat "pdflatex " bib-base))
    (shell-command (concat "pdflatex " bib-base))
    (kill-buffer texfile)
    (org-open-file pdffile)
    )) 
#+END_SRC

** Extract bibtex entries cited in an org-file
When you use your default bibliography file, and you want to send an org-file to a collaborator, you may need to include bibtex entries so the other person can see them. This function does that and puts the entries in a section at the end of the document that can be tangled to a bib-file.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(defun org-ref-extract-bibtex-entries ()
  "extract the bibtex entries referred to by cite links in the current buffer into a src block at the bottom of the current buffer.

If no bibliography is in the buffer the `reftex-default-bibliography' is used."
  (interactive)
  (let* ((tempname (make-temp-file "extract-bib"))
         (contents (buffer-string))
         (cb (current-buffer))
	 basename texfile bibfile results)
    
    ;; open tempfile and insert org-buffer contents
    (find-file tempname)
    (insert contents)
    (setq basename (file-name-sans-extension 
		    (file-name-nondirectory buffer-file-name))
	  texfile (concat tempname ".tex")
	  bibfile (concat tempname ".bib"))
    
    ;; see if we have a bibliography, and insert the default one if not.
    (save-excursion
      (goto-char (point-min))
      (unless (re-search-forward "^bibliography:" (point-max) 'end)
	(insert (format "\nbibliography:%s" 
			(mapconcat 'identity reftex-default-bibliography ",")))))
    (save-buffer)

    ;; get a latex file and extract the references
    (org-latex-export-to-latex)
    (find-file texfile)
    (reftex-parse-all)
    (reftex-create-bibtex-file bibfile)
    (save-buffer)
    ;; save results of the references
    (setq results (buffer-string))

    ;; kill buffers. these are named by basename, not full path
    (kill-buffer (concat basename ".bib"))
    (kill-buffer (concat basename ".tex"))
    (kill-buffer basename)

    (delete-file bibfile)
    (delete-file texfile)
    (delete-file tempname)

    ;; Now back to the original org buffer and insert the results
    (switch-to-buffer cb)
    (when (not (string= "" results))
      (save-excursion
        (goto-char (point-max))
        (insert "\n\n"
        (org-insert-heading-after-current)
        (insert (format " Bibtex entries

,#+BEGIN_SRC: text :tangle %s
%s
,#+END_SRC" bibfile results)))))))
#+END_SRC

** Find bad cite links
Depending on how you enter citations, you may have citations with no corresponding bibtex entry. This function finds them and gives you a clickable table to navigate to them.

#+BEGIN_SRC emacs-lisp  :tangle org-ref.el
(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn 
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))


(defun org-ref-bib-find-bad-citations ()
  "Create a list of citation keys in an org-file that do not have a bibtex entry in the known bibtex files.

Makes a new buffer with clickable links."
  (interactive)
  ;; generate the list of bibtex-keys and cited keys
  (let* ((bibtex-files (org-ref-find-bibliography))
	 (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
	 (bad-citations '()))

    (org-element-map (org-element-parse-buffer) 'link
      (lambda (link)       
	(let ((plist (nth 1 link)))			     
	  (when (equal (plist-get plist ':type) "cite")
	    (dolist (key (org-ref-split-and-strip-string (plist-get plist ':path)) )
	      (when (not (index key bibtex-keys))
		(setq bad-citations (append bad-citations
					    `(,(format "%s [[elisp:(progn (switch-to-buffer-other-frame \"%s\")(goto-char %s))][not found here]]\n"
						       key (buffer-name)(plist-get plist ':begin)))))
		))))))

    (if identity bad-citations
      (progn
	(switch-to-buffer-other-window "*Missing citations*")
	(org-mode)
	(erase-buffer)
	(insert "* List of bad cite links\n")
	(insert (mapconcat 'identity bad-citations ""))
					;(setq buffer-read-only t)
	(use-local-map (copy-keymap org-mode-map))
	(local-set-key "q" #'(lambda () (interactive) (kill-buffer))))
      (message "No bad cite links found"))))
#+END_SRC

** Finding non-ascii characters
I like my bibtex files to be 100% ascii. This function finds the non-ascii characters so you can replace them. 

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-find-non-ascii-characters ()
  "finds non-ascii characters in the buffer. Useful for cleaning up bibtex files"
  (interactive)
  (occur "[^[:ascii:]]"))
#+END_SRC

** Resort a bibtex entry
I like neat and orderly bibtex entries.That means the fields are in a standard order that I like. This function reorders the fields in an entry for articles.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-sort-bibtex-entry ()
  "sort fields of entry in standard order and downcase them"
  (interactive)
  (bibtex-beginning-of-entry)
  (let* ((master '("author" "title" "journal" "volume" "issue" "pages" "year" "doi" "url"))
	 (entry (bibtex-parse-entry))
	 (entry-fields)
	 (other-fields)
	 (type (cdr (assoc "=type=" entry)))
	 (key (cdr (assoc "=key=" entry))))

    ;; these are the fields we want to order that are in this entry
    (setq entry-fields (mapcar (lambda (x) (car x)) entry))
    ;; we do not want to reenter these fields
    (setq entry-fields (remove "=key=" entry-fields))
    (setq entry-fields (remove "=type=" entry-fields))

    ;;these are the other fields in the entry
    (setq other-fields (remove-if-not (lambda(x) (not (member x master))) entry-fields))

    (cond
     ;; right now we only resort articles
     ((string= type "article")
      (bibtex-kill-entry)
      (insert
       (concat "@article{" key ",\n" 
	       (mapconcat  
		(lambda (field) 
		  (when (member field entry-fields)
		    (format "%s = %s," (downcase field) (cdr (assoc field entry))))) master "\n")
	       (mapconcat 
		(lambda (field) 
		  (format "%s = %s," (downcase field) (cdr (assoc field entry)))) other-fields "\n")
	       "\n}\n\n"))
      (bibtex-find-entry key)
      (bibtex-fill-entry)
      (bibtex-clean-entry)
       ))))
#+END_SRC

** Clean a bibtex entry
   I like neat and orderly bibtex entries. This code will eventually replace the key with my style key, clean the entry, and sort the fields in the order I like them.
see [[file:emacs-24.3/lisp/textmodes/bibtex.el::bibtex-autokey-before-presentation-function]] for how to set a function that checks for uniqueness of the key.
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defun org-ref-clean-bibtex-entry()
  "clean and replace the key in a bibtex function"
  (interactive)
  (bibtex-beginning-of-entry)

  ;; check for empty pages, and put eid or article id in its place
  (let ((entry (bibtex-parse-entry))
	(pages (bibtex-autokey-get-field "pages"))
	(year (bibtex-autokey-get-field "year"))
        ;; The Journal of Chemical Physics uses eid
	(eid (bibtex-autokey-get-field "eid")))

    ;; asap articles often set year to 0, which messes up key generation. fix that.
    (when (string= "0" year)  
      (bibtex-beginning-of-entry)
      (goto-char (car (cdr (bibtex-search-forward-field "year" t))))
      (bibtex-kill-field)
      (bibtex-make-field "year")
      (backward-char)
      (insert (read-string "Enter year: ")))

    ;; fix pages if they are empty
    (when (string= "-" pages)
      (when eid	  
	(bibtex-beginning-of-entry)
	;; this seems like a clunky way to set the pages field.But I
	;; cannot find a better way.
	(goto-char (car (cdr (bibtex-search-forward-field "pages" t))))
	(bibtex-kill-field)
	(bibtex-make-field "pages")
	(backward-char)
	(insert eid)))

    ;; replace naked & with \&
    (save-restriction
      (bibtex-narrow-to-entry)
      (bibtex-beginning-of-entry)
      (message "checking &")
      (replace-regexp " & " " \\\\& ")
      (widen))

    ;; generate a key, and if it duplicates an existing key, edit it.
    (let ((key (bibtex-generate-autokey)))

      ;; first we delete the existing key
      (bibtex-beginning-of-entry)
      (re-search-forward bibtex-entry-maybe-empty-head)
      (if (match-beginning bibtex-key-in-head)
	  (delete-region (match-beginning bibtex-key-in-head)
			 (match-end bibtex-key-in-head)))
      ;; check if the key is in the buffer
      (when (save-excursion
	      (bibtex-search-entry key))
	  (setq key (bibtex-read-key "Duplicate Key found, edit: " key)))

      (insert key)
      (kill-new key)) ;; save key for pasting	    

    (org-ref-sort-bibtex-entry)
    ;; check for non-ascii characters
    (occur "[^[:ascii:]]")
    ))
#+END_SRC
* Aliases
I like convenience. Here are some aliases for faster typing.

#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(defalias 'oro 'org-ref-open-citation-at-point)
(defalias 'orc 'org-ref-citation-at-point)
(defalias 'orp 'org-ref-open-pdf-at-point)
(defalias 'oru 'org-ref-open-url-at-point)
(defalias 'orn 'org-ref-open-notes-at-point)

(defalias 'orib 'org-ref-insert-bibliography-link)
(defalias 'oric 'org-ref-insert-cite-link)
(defalias 'orir 'org-ref-insert-ref-link)
(defalias 'orsl 'org-ref-store-bibtex-entry-link)

(defalias 'orcb 'org-ref-clean-bibtex-entry)
#+END_SRC
* End of code
#+BEGIN_SRC emacs-lisp :tangle org-ref.el
(provide 'org-ref)
#+END_SRC


* Build								   :noexport:

[[elisp:(progn (org-babel-tangle) (load-file "org-ref.el"))]]

[[elisp:(org-babel-load-file "org-ref.org")]]



