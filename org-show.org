#+TITLE: org-show - simple presentations in org-mode
#+AUTHOR: John Kitchin

There are several options for "presenting" from org-mode. Here are the options I found.

https://github.com/rlister/org-present
https://github.com/eschulte/epresent

https://github.com/yjwen/org-reveal
https://github.com/takaxp/org-tree-slide/
https://github.com/tucasp/org-presie

http://orgmode.org/worg/exporters/beamer/tutorial.html
http://orgmode.org/worg/org-tutorials/non-beamer-presentations.html#sec-3

The one I like the best is discussed here: http://sachachua.com/blog/2013/04/how-to-present-using-org-mode-in-emacs/. I like it best because you can edit the slides as you go, execute arbitrary emacs code, and it is still pretty simple. I used Sacha's code as the basis for org-show. There is a lot of similarity.

* org-show
You can have: 

1. code run
2. split to show slide and full image
3. plain text

** Title slide 							      :slide:
#+BEGIN_SRC emacs-lisp-slide
(require 'animate)
(switch-to-buffer (get-buffer-create
                     (or animation-buffer-name
                         "*Animation*")))
(erase-buffer)
(text-scale-set 6)
(let* ((strings (list "Emacs + org-mode" "John Kitchin" "" "July 1, 2014" "Carnegie Mellon University"))
       (vpos (/ (- 20
                   1 ;; For the mode-line
                   (1- (length strings)) 
                   (length strings))
                2))
       (width 43)
       hpos)
  (while strings
    (setq hpos (/ (- width (length (car strings))) 2))
    (animate-string (car strings) vpos hpos)
    (setq vpos (1+ vpos))
    (setq strings (cdr strings))))
#+END_SRC

** Presentations in org-mode					      :slide:
This should be easy

1. Create org-file
2. Run command to start
3. Navigate through slides, edit as you present

** Equations							      :slide:
It should be easy to show equations like this  $\int_0^x \frac{1}{2} \sin x dx = 6$.

It is. Maybe you prefer numbered equations?


\begin{equation}
e^x = 5
\end{equation}

The numbering is not consecutive:

\begin{equation}
2+2=4
\end{equation}


Want to see the equation source? [[elisp:(org-ctrl-c-ctrl-c)][click here]]

** Figures							      :slide:

Figures should show up in two panes.
[[./taskbar.png]]


The text should show also.
** A complicated layout						      :slide:
#+BEGIN_SRC emacs-lisp-slide
(delete-other-windows)
(split-window-right)
(other-window 1)
(find-file "arxiv.el")
(split-window-below)
(other-window 1)
(find-file "doi-utils.org")
#+END_SRC
** Code blocks should be runnable and editable			      :slide:

#+BEGIN_SRC python
print 6 + 6
#+END_SRC

#+RESULTS:
: 12

They are.
** We can use many languages 					      :slide:
(of course, you must have them installed on your computer)

#+BEGIN_SRC emacs-lisp
(+ 6 6)
#+END_SRC

#+RESULTS:
: 12


#+BEGIN_SRC R 
sum(c(6, 6))
#+END_SRC

#+RESULTS:
: [1] 12


#+BEGIN_SRC perl :results output
print 6 + 6
#+END_SRC

#+RESULTS:
: 12


#+BEGIN_SRC ruby
print 6 + 6
#+END_SRC


#+BEGIN_SRC matlab
% Sadly only on Mac and Linux. That's a deal breaker...
#+END_SRC
** Interactivity is important	
We get it.
*** Snake							      :slide:
#+BEGIN_SRC emacs-lisp-slide
(snake)
#+END_SRC

*** tetris							      :slide:

#+BEGIN_SRC emacs-lisp-slide
(when (and (boundp 'snake-buffer-name) (get-buffer snake-buffer-name))
  (kill-buffer snake-buffer-name))
(delete-other-windows)
(tetris)
#+END_SRC


*** doctor							      :slide:
#+BEGIN_SRC emacs-lisp-slide
(doctor)
#+END_SRC


*** Become a graffiti artist 					      :slide:
#+BEGIN_SRC emacs-lisp-slide
(progn
  (switch-to-buffer (get-buffer-create "*artist*"))
  (erase-buffer)
  (artist-mode 1)
  (menu-bar-mode 1)
  (text-scale-set 0)
  (artist-select-op-spray-can))
#+END_SRC


*** Or draw lines						      :slide:
#+BEGIN_SRC emacs-lisp-slide
(progn
  (switch-to-buffer (get-buffer-create "*artist*"))
  (artist-select-op-line))
#+END_SRC

** No seriously, we can do real work! 				      :slide:
   :PROPERTIES:
   :CUSTOM_ID: sec:data-tab-code
   :END:
#+tblname: tab-data
| x |  y |
|---+----|
| 1 |  1 |
| 2 |  4 |
| 3 |  9 |
| 4 | 16 |

#+BEGIN_SRC python :var data=tab-data
import matplotlib.pyplot as plt
import numpy as np
d = np.array(data)
plt.plot(d[:,0], d[:,1])
plt.show()
#+END_SRC  

#+RESULTS:

You can make links to a table like this: ref:tab-data.
** Interactive links						      :slide:
<<beginning>>

You can have links that take you to places: [[beginning]], [[end]], to a [[#sec:data-tab-code][section]],

Or links that are functional: cite:mehta-2014-ident-poten. 

Or that run code [[elisp:(message "Hello %s" user-full-name)]]

Or links to an email: https://mail.google.com/mail/u/0/#search/portuguese+pycse/14253be65959394f

Or to open a [[http://kitchingroup.cheme.cmu.edu][website]].

<<end>>
** Conclusions							      :slide:
That is the end!

#+BEGIN_SRC emacs-lisp-slide
(org-show-animate '("The End" "Thank you for your attention" "" "Questions?"))
#+END_SRC


* The code

** The header

#+BEGIN_SRC emacs-lisp :tangle org-show.el
;;; org-show.el --- Summary
;; Copyright(C) 2014 John Kitchin

;; Author: John Kitchin <jkitchin@andrew.cmu.edu>
;; Contributions from Sacha Chua.
;; This file is not currently part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or (at
;; your option) any later version.

;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program ; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary:
;; A simple mode for presenting org-files as slide-shows
#+END_SRC

** Some basic setup
#+BEGIN_SRC emacs-lisp :tangle org-show.el
(require 'eimp)

(defvar org-show-presentation-file nil "File containing the presentation.")
(defvar org-show-slide-tag "slide" "Tag that marks slides.")
(defvar org-show-slide-tag-regexp (concat ":" (regexp-quote org-show-slide-tag) ":"))
(defvar org-show-latex-scale 4.0 "scale for latex preview")
(defvar org-show-text-scale 4 "scale for text in presentation")
(defvar org-show-current-slide-number 1 "holds current slide number")

;; From org-pres--eimp-fit
(defun org-show-eimp-fit ()
  "Function used as a hook, fits the image found to the window."
  (when (eq major-mode 'image-mode)
    (eimp-fit-image-to-window nil)))

(add-hook 'find-file-hook 'org-show-eimp-fit)
#+END_SRC

** Make a minor mode and menu

#+BEGIN_SRC emacs-lisp :tangle org-show.el
(require 'easymenu)

(defvar org-show-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map [next] 'org-show-next-slide)
    (define-key map [prior] 'org-show-previous-slide)
    
    (define-key map [f5] 'org-show-start-slideshow)
    (define-key map [f6] 'org-show-execute-slide)
    (define-key map (kbd "\e\eg") 'org-show-goto-slide)
    (define-key map (kbd "\e\et") 'org-show-toc)
    (define-key map (kbd "\e\eq") 'org-show-stop-slideshow)
    map)
  "Keymap for org-show-mode.")

(easy-menu-define my-menu org-show-mode-map "My own menu"
  '("org-show"
    ["Start slide show" org-show-start-slideshow t]
    ["Next slide" org-show-next-slide t]
    ["Previous slide" org-show-previous-slide t]
    ["Open this slide" org-show-open-slide t]
    ["Goto slide" org-show-goto-slide t]
    ["Table of contents" org-show-toc t]
    ["Stop slide show"  org-show-stop-slideshow t]
))


(define-minor-mode org-show-mode
  "Minor mode for org-show

\\{org-show-mode-map}"
  :lighter " org-show"
  :global t
  :keymap org-show-mode-map)
#+END_SRC

** Prepare and show the slide 

#+BEGIN_SRC emacs-lisp :tangle org-show.el
(defun org-show-execute-slide ()
  "Process slide at point.
  If it contains an Emacs Lisp source block, evaluate it.
  If it contains an image, view it in a split buffer
  Else, focus on that buffer.
  Hide all drawers."
  (interactive)
  (setq org-show-presentation-file (expand-file-name (buffer-name)))
  (delete-other-windows)  

  ;; make sure nothing is folded. This seems to be necessary to
  ;; prevent an error on narrowing then trying to make latex fragments
  ;; I think.
  (org-cycle '(64))

  (org-narrow-to-subtree)
  (visual-line-mode 1)
  (let ((heading-text (nth 4 (org-heading-components)))
        (org-format-latex-options (plist-put org-format-latex-options :scale org-show-latex-scale)))

    (set-frame-name (format "%-180s%15s%s" heading-text "slide " (cdr (assoc heading-text org-show-slide-titles))))

    ;; preview equations in the current subtree
    (org-preview-latex-fragment '(4))
    (message "") ; clear minibuffer
    (cond

     ;; view images if there is one
     ((and (goto-char (point-min))
           (re-search-forward "\\[\\[.*\\.\\(jpg\\|gif\\|png\\)" nil t))
      (split-window-right)      
      (other-window 1)
      (let ((org-link-frame-setup '((file . find-file))))
        (org-open-at-point))
      (other-window 1) ; back to slide
      (goto-char (point-min))
      (text-scale-set org-show-text-scale)
      (org-display-inline-images)
      (org-cycle-hide-drawers t)
      (org-show-subtree))

     ;; find and execute source code blocks.
     ;; you can either have images, or code. Not both.
     ;; Only code blocks of type emacs-lisp-slide are used.
     ((and (goto-char (point-min))
           (re-search-forward "#\\+begin_src emacs-lisp-slide" nil t))
      (let ((info (org-babel-get-src-block-info)))
        (unwind-protect
            (eval (read (concat "(progn " (nth 1 info) ")"))))))

     ;; plain text slides
     (t
      (switch-to-buffer (current-buffer))
      (text-scale-set org-show-text-scale)
      (org-show-subtree)
      (org-cycle-hide-drawers t)
      (org-display-inline-images)
      (delete-other-windows)))))
#+END_SRC

** Next and previous slides

#+BEGIN_SRC emacs-lisp :tangle org-show.el
(defun org-show-next-slide ()
  "Goto next slide in presentation"
  (interactive)
  (find-file org-show-presentation-file)
  (widen)
  (if (< (+ org-show-current-slide-number 1) (length org-show-slide-titles))
      (progn
	(setq org-show-current-slide-number (+ org-show-current-slide-number 1))
	(org-show-goto-slide org-show-current-slide-number))
    (org-show-goto-slide org-show-current-slide-number)
    (message "This is the end. My only friend the end.  Jim Morrison.")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle org-show.el
(defun org-show-previous-slide ()
  "Goto previous slide in the list"
  (interactive)
  (find-file org-show-presentation-file)
  (widen)
  (if (> (- org-show-current-slide-number 1) 0)
      (progn
	(setq org-show-current-slide-number (- org-show-current-slide-number 1))
	(org-show-goto-slide org-show-current-slide-number))
    (org-show-goto-slide org-show-current-slide-number)
    (message "Once upon a time...")))
#+END_SRC

** Open this slide

#+BEGIN_SRC emacs-lisp :tangle org-show.el
(defun org-show-open-slide ()
 "Start show at this slide"
 (setq org-show-presentation-file (expand-file-name (buffer-name))) 
 (org-show-initialize)
 (let ((n (cdr (assoc (nth 4 (org-heading-components)) org-show-slide-titles))))
   (setq org-show-current-slide-number n)
   (org-show-goto-slide n)))
#+END_SRC

** Starting the show
We need some functions for convenient starting and stopping.

On starting, we want to map the slides so we can get slide numbers for navigation and to display them on the frame. We also make the slide tags invisible. We set some temporary key bindings. These need to be global because sometimes we navigate out of the slideshow buffer, and we want page up and down to go to the next slides no matter where we are.


#+BEGIN_SRC emacs-lisp :tangle org-show.el
(defvar org-show-slide-list '() "List of slide numbers and markers to each slide")
(defvar org-show-slide-titles '() "List of titles and slide numbers for each slide")

(defun org-show-initialize ()
  ;; make slide lists for future navigation. rerun this if you change slide order
  (setq  org-show-slide-titles '()
         org-show-slide-list '())
     
  (let ((n 0))
    (org-map-entries
     (lambda ()
       (when (string-match-p ":slide:" (or (nth 5 (org-heading-components)) ""))
	 (setq n (+ n 1))
         
	 (add-to-list 'org-show-slide-titles 
		      (cons (nth 4 (org-heading-components)) n) t)

	 (add-to-list 'org-show-slide-list 
		      (cons n (set-marker (make-marker) (point))) t))))))

(defun org-show-start-slideshow ()
  "Start the slide show, at the beginning"
  (interactive)
  
  (setq org-show-presentation-file (expand-file-name (buffer-name)))
  (beginning-of-buffer)
  (org-show-initialize)
  ;; hide slide tags
  (save-excursion
    (while (re-search-forward ":slide:" nil t)
      (overlay-put
       (make-overlay (match-beginning 0)(match-end 0))
       'invisible 'slide)))
  (add-to-invisibility-spec 'slide)

  (beginning-of-buffer)
  (delete-other-windows)
  (org-show-mode 1)
  (setq org-show-current-slide-number 1)
  (org-show-goto-slide 1))
#+END_SRC

** Stop the show

#+BEGIN_SRC emacs-lisp :tangle org-show.el
(defun org-show-stop-slideshow ()
  (interactive)
  (find-file org-show-presentation-file)
  ;; make slide tag visible again
  (remove-from-invisibility-spec 'slide)
  (widen)
  (text-scale-set 0)
  (delete-other-windows)
  (setq org-show-presentation-file nil)
  (setq org-show-current-slide-number 1)
  (org-show-mode -1))

(defalias 'stop 'org-show-stop-slideshow)
#+END_SRC

** Goto a slide
#+BEGIN_SRC emacs-lisp :tangle org-show.el
(defun org-show-goto-slide (n)
 "Goto slide N"
 (interactive "nSlide number: ")
 (message "Going to slide %s" n)
 (find-file org-show-presentation-file)
 (setq org-show-current-slide-number n)
 (widen)
 (goto-char (cdr (assoc n org-show-slide-list)))
 (org-show-execute-slide))
#+END_SRC

** Table of contents
#+BEGIN_SRC emacs-lisp :tangle org-show.el
(defun org-show-toc ()
  (interactive)
  (let ((links) (c-b (buffer-name)) (n))
    (save-excursion
      (widen)
      (mapcar
       (lambda (x)
	 (setq n (car x))
	 (goto-char (cdr x))
	 (add-to-list
	  'links
	  (format " [[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s)(org-show-execute-slide))][%2s %s]]\n\n"
		  (marker-buffer (cdr x))
		  (marker-position (cdr x))
		  (car x)
		  (nth 4 (org-heading-components))) t))
	      org-show-slide-list))
    
    (switch-to-buffer "*List of Slides*")
    (org-mode)
    (erase-buffer)
    
    (insert (mapconcat 'identity links ""))
  
    ;(setq buffer-read-only t)
    (use-local-map (copy-keymap org-mode-map))
    (local-set-key "q" #'(lambda () (interactive) (kill-buffer)))))
#+END_SRC

** Utilities
It seems like we might animate enough to have a function
#+BEGIN_SRC emacs-lisp :tangle org-show.el
(require 'animate)

(defun org-show-animate (strings)
  "Animate STRINGS in an *Animation* buffer"
  (switch-to-buffer (get-buffer-create
                     (or animation-buffer-name
                         "*Animation*")))
  (erase-buffer)
  (text-scale-set 6)
  (let* ((vpos (/ (- 20
		     1 ;; For the mode-line
		     (1- (length strings)) 
		     (length strings))
		  2))
	 (width 43)
	 hpos)
    (while strings
      (setq hpos (/ (- width (length (car strings))) 2))
      (when (> 0 hpos) (setq hpos 0))
      (when (> 0 vpos) (setq vpos 0))
      (animate-string (car strings) vpos hpos)
      (setq vpos (1+ vpos))
      (setq strings (cdr strings)))))
#+END_SRC
** End
#+BEGIN_SRC emacs-lisp  :tangle org-show.el
(provide 'org-show)
#+END_SRC
* build
[[elisp:(org-babel-load-file "org-show.org")]]
